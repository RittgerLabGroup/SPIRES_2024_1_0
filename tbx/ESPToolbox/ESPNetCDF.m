classdef ESPNetCDF < handle
    % ESPNetCDF - class for writing ESP data related to a region to NetCDF-CF files
    % Projection MODIS Sinusoidal only.
    % NB: only works with modis tiles 2023-08-31.
    %
    % Use case
    % --------
%{
    label = 'v2023.1'; % or 'v2022.0' for v03 HMA ASHimalaya.
    if strcmp(label, 'v2023.1')
        modisData = MODISData(label = 'v2023.1', versionOfAncillary = 'v3.1');
        regionName = 'h08v04';
        thisDate = datetime(2023, 1, 1);
    elseif strcmp(label, 'v2022.0')
        modisData = MODISData(label = 'v03', versionOfAncillary = 'v3.2');
        modisData.versionOf.VariablesNetCDF = 'v2022.0';
        regionName = 'h24v05';
        thisDate = datetime(2022, 4, 1);
    end
    espEnv = ESPEnv(modisData = modisData, scratchPath = ESPEnv.defaultArchivePath);
    region = Regions(regionName, [regionName, '_mask'], espEnv, modisData);
    matFilePath = espEnv.getFilePathForDateAndVarName(regionName, 'VariablesMatlab', ...
        thisDate, '');
    netCDFFilePath = espEnv.getFilePathForDateAndVarName(regionName, ...
        'VariablesNetCDF', thisDate, '');
    ESPNetCDF.generateNetCDFFromRegionAndMatFile(region, thisDate, matFilePath, ...
        netCDFFilePath);
%}
    properties
        globalAttribute      % global attributes to write
        ncid           % NetCDF fileID
        netCDFFilePath     % NetCDF file to write
        grid_mapping   % name of CF variable with projection information
        region         % Region obj.
        thisDate    % datetime. Date of the data saved in the file.
    end
    properties(Constant)
        epochDt = datetime('2000-01-01 00:00:00');
        defaultGlobalAttribute = struct(...
            title = ['MODIS/Terra L3 Global Daily 500m Sinusoidal ', ...
            'Spatially and Temporally Complete (STC) Snow Cover and ', ...
            'Snow Surface Properties'], ...
            Conventions = 'CF-1.10, ACDD-1.3', ...
            source = ['MOD09GA Collection 6, includes v006 and ', ...
            '(beginning 28 Dec 2021) v061 files'], ...
            standard_name_vocabulary = 'CF Standard Name Table (v82,Â 06 July 2023)', ...
            summary = ['This data set contains spatially and temporally ', ...
            'complete (STC) raster images of snow cover and snow ', ...
            'surface properties derived from MODSCAG and MODDRFS. ', ...
            'STC improvements include cloud detection, off-nadir ', ...
            'viewing and adjustment for snow occluded by forests ', ...
            'from the satellite.'], ...
            history = 'Produced by ESPToolbox.', ...
            comment = ['Stillinger et al. (2023) used for snow cover ', ...
            'validation with 3 m airborne snow maps; ', ...
            'Rittger et al. (2021) used for application and comparison ', ...
            'of Landsat 8, MODIS, and VIIRS; ', ...
            'Rittger et al. (2020) used for gap filling procedure ', ...
            'for snow cover (also used on other variables); ', ...
            'Bair et al. (2019) used for albedo validation with 3 ', ...
            'in-situ stations; ', ...
            'Rittger et al. (2013) used for Landsat 5 and 7 comparison ', ...
            'to MODSCAG and MOD10A1 binary and fractional; ', ...
            'Painter et al. (2012) used for MODDRFS algorithm; ', ...
            'Painter et al. (2009) used for MODSCAG algorithm; ', ...
            'Dozier et al. (2008) used for interpolation and off-nadir ', ...
            'weighting of observations.'], ...
            references = ['Stillinger, T., K. Rittger, M.S. Raleigh, ', ...
            'A. Michell, R.E. Davis, and E.H. Bair. 2023. Landsat, ', ...
            'MODIS, and VIIRS snow cover mapping algorithm performance ', ...
            'as validated by airborne lidar datasets. The Cryosphere ', ...
            '17: 567-590, doi:10.5194/tc-17-567-2023. ' newline, ...
            'Rittger, K., K. J. Bormann, E. H. Bair, J. Dozier, and ', ...
            'T. H. Painter. 2021. Evaluation of VIIRS and MODIS Snow ', ...
            'Cover Fraction in High-Mountain Asia Using Landsat 8 OLI. ', ...
            'Frontiers in Remote Sensing, 2 (8). ', ...
            'doi:10.3389/frsen.2021.647154. ' newline, ...
            'Rittger, K., M. S. Raleigh, J. Dozier, A. F. Hill, ', ...
            'J. A. Lutz, and T. H. Painter. 2020. Canopy Adjustment ', ...
            'and Improved Cloud Detection for Remotely Sensed Snow Cover ', ...
            'Mapping. Water Resources Research, 55. ', ...
            'doi:10.1029/2019WR024914. ' newline, ...
            'Bair, E. H., K. Rittger, S. M. Skiles, and J. Dozier. 2019. ', ...
            'An Examination of Snow Albedo Estimates From MODIS and ', ...
            'Their Impact on Snow Water Equivalent Reconstruction. ', ...
            'Water Resources Research, 55, 7826-7842, ', ...
            'doi:10.1029/2019wr024810. ' newline, ...
            'Rittger, K., T. H. Painter, and J. Dozier. 2013. ', ...
            'Assessment of methods for mapping snow cover from MODIS. ', ...
            'Advances in Water Resources, 51, 367-380, ', ...
            'doi:10.1016/j.advwatres.2012.03.002. ' newline, ...
            'Painter, T. H., A. C. Bryant, and S. M. Skiles. 2012. ', ...
            'Radiative forcing by light absorbing impurities in snow ', ...
            'from MODIS surface reflectance data. Geophysical ', ...
            'Research Letters, 39, L17502, ', ...
            'doi:10.1029/2012gl052457. ' newline, ...
            'Painter, T. H., K. Rittger, C. McKenzie, P. Slaughter, ', ...
            'R. E. Davis, and J. Dozier. 2009. Retrieval of subpixel ', ...
            'snow covered area, grain size, and albedo from MODIS. ', ...
            'Remote Sensing of Environment, 113(4): 868-879. ', ...
            'doi:10.1016/j.rse.2009.01.001. ' newline, ...
            'Dozier, J., T. H. Painter, K. Rittger, and J. E. Frew. ', ...
            '2008. Time-space continuity of daily maps of fractional ', ...
            'snow cover and albedo from MODIS. Advances in Water ', ...
            'Resources, 31(11): 1515-1526. ', ...
            'doi:10.1016/j.advwatres.2008.08.011. '], ...
            publisher_institution = 'Institute for Arctic and Alpine Research', ...
            publisher_name = 'Institute for Arctic and Alpine Research', ...
            publisher_type = 'institution', ...
            publisher_url = 'https://nsidc.org/snow-today', ...
            publisher_email = 'snow-today@nsidc.org', ...
            acknowledgement = ['These data are produced and ', ...
            'supported by the Institute of Arctic and Alpine ', ...
            'Research. The data products were produced with funding ', ...
            'from NASA grants 80NSSC18K0427, 80NSSC20K1721, ', ...
            '80NSSC22K0703, 80NSSC22K0929, 80NSSC18K1489, ', ...
            '80NSSC20K1349. This work utilized ', ...
            'the Alpine high performance computing resource at the ', ...
            'University of Colorado Boulder. Alpine is jointly ', ...
            'funded by the University of Colorado Boulder, the ', ...
            'University of Colorado Anschutz, and Colorado State ', ...
            'University. Data storage supported by the University ', ...
            'of Colorado Boulder PetaLibrary.'], ...
            license = ['Access Constraint: These data are freely, ', ...
            'openly, and fully accessible; ', ...
            'Use Constraint: These data are freely, openly, and fully ', ...
            'available to use without restrictions, provided that you ', ...
            'cite the data according to the recommended citation ', ...
            'included here.'], ...
            creator_name = 'Karl Rittger', ...
            creator_url = 'https://www.colorado.edu/instaar/karl-rittger', ...
            creator_email = 'karl.rittger@colorado.edu', ...
            contributor_name = ['Karl Rittger, Mary J. Brodzik, ', ...
            'Sebastien J. P. Lenard, Ross T. Palomaki, Jessica Calme'], ...
            contributor_role = ['principal_investigator, developer, ', ...
            'research_scientist, postdoc, data_manager'], ...
            citation = ['Rittger, K., M. J. Brodzik, S. J. P. Lenard, ', ...
                'Ross T. Palomaki, T. Stillinger, E. H. Bair, J. Dozier and ', ...
                'T. H. Painter. 2023. ', ...
                'MODIS/Terra L3 Global Daily 500m Sinusoidal ', ...
                'Spatially and Temporally Complete (STC) Snow Cover ', ...
                'and Snow Surface Properties, Version ', ...
                '{product_version}', ...
                ' INSTAAR, Boulder, CO, USA. Digital Media.']);
            % NB: Citation included at the end :
            % 'ftp://dtn.rc.colorado.edu/shares/snow-today, doi:TO UPDATE'
            % but removed because ftp doesn't work and doi unavailable.
            % NB: The properties also included: id = 'DOI TO UPDATE'
            % but removed because doi unavailable.
            %
            % TODO: add back these fields when the values will be available!
            %                                                                      @todo
            %                                                                 @important

        % NB: all citations should follow Chicago style, where only the first name is
        % inverted with the family name and last person is preceded by a 'and'.
        % https://www.chicagomanualofstyle.org/book/ed17/part3/ch14/psec076.html
        defaultAttributeValues = struct(v2022_0 = struct(stcStruct = struct( ...
            mindays = 10, zthresh = [800, 800], rawRovDV = [0, 100], ...
            rawRovRF = [0, 400], temporalRovDV = [0, 70], temporalRovRF = [0, 500], ...
            sthreshForGS = 0.3, sthreshForRF = 0.3, minZForNonForestedAdjust = 'n/a', ...
            nonForestedScaleFactor = 'n/a', minSnowForVegAdjust = 'n/a', ...
            canopyToTrunkRatio = 'n/a'))); % default values for v03/v2022.0 hard coded
                % because unavailable in mosaic .mat file. Values               @tocheck
        % Mapping of NetCDF types to Matlab classes
        % I thought I could find it in the NetCDF API, but I don't see it
        matClass = containers.Map(...
                {'NC_DOUBLE', 'NC_FLOAT', 'NC_INT64', 'NC_UINT64', ...
                'NC_INT', 'NC_UINT', 'NC_SHORT', 'NC_USHORT', ...
                'NC_BYTE', 'NC_UBYTE', 'NC_CHAR', 'NC_STRING'}, ...
                {'double', 'single', 'int64', 'uint64', ...
                'int32', 'uint32', 'int16', 'uint16', ...
                'int8', 'uint8', 'char', 'string'});
    end
    methods
        function obj = ESPNetCDF(region, thisDate)
            % ESPNetCDF constructor, initializes global/projection metadata
            %
            % Parameters
            % ----------
            % region: Region obj. Should be tile region.
            %
            % Return
            % ------
            % obj:  ESPNetCDF Obj.
            obj.region = region;
            obj.thisDate = thisDate;
            obj = obj.setGlobalAttributes();
        end
        function obj = addGlobalAttributes(obj, attribute)
            % Adds global attributes to currently open nc file
            %
            % attribute: struct with string attributes to set

            varid = netcdf.getConstant('GLOBAL');

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                    fNames{i}, attribute.(fNames{i}));
            end
        end
        function closeFile(obj)
            % Set the crs and date information and close the NetCDF file.

            % 1. Initialize.
            if ~obj.ncid
                fprintf('%s: no open file id to write\n', mfilename());
                return;
            end
            modisData = obj.region.espEnv.modisData;
            % Populate the coordinate reference system (crs)
            % information
            % Verify MODIS sinusoidal
            if ~ismember('modisSinusoidal', ...
                fieldnames(modisData.projection))
                ME = MException('ESPNetCDF:inputError', ...
                    '%s: unexpected modisData', ...
                mfilename());
                throw(ME)
            end

            % 2. Populate the GeoTransform.
            % A geotransform consists in a set of 6 coefficients:
            %
            % GT(0) x-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(1) w-e pixel resolution / pixel width.
            % GT(2) row rotation (typically zero).
            % GT(3) y-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(4) column rotation (typically zero).
            % GT(5) n-s pixel resolution / pixel height
            %       (negative value for a north-up image).
            %
            % See details:
            % https://gdal.org/tutorials/geotransforms_tut.html
            % After an e-mail exchange with Scott 2023-09-07, it appears that the
            % Geotransform is a string separated by spaces and ended by a space.

            myRR = obj.region.getMapCellsReference();
            GeoTransform = [...
                num2str(myRR.XWorldLimits(1)), ' ', ...
                num2str(myRR.CellExtentInWorldX), ' ', '0.0', ' ', ...
                num2str(myRR.YWorldLimits(2)), ' ', '0.0', ' ', ...
                num2str(-1 * myRR.CellExtentInWorldY), ' '];
            params = myRR.ProjectedCRS.ProjectionParameters;

            % 3.Define the crs variable. It is instantiated first with name 'sinusoidal'
            % to be referable in the corresponding attributes of each variable,
            % and then crs. I parametered the 'sinusoidal' with what works for QGIS 3.28
            % and let the crs as parametered as Mary Jo did. Note that before 2023-08-31
            % only crs was parametered and there was no sinusoidal var.
            % Not sure if both 'crs' and 'sinusoidal' variables are
            % necessary but it's better to let them as such for now.            @tocheck
            %
            % Projection CF netcdf doc:
            % http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#_sinusoidal
            %
            % It will be no data, just attributes
            % Indicate that there is no dimid with []
            % No need to call putVar since there's no data here
            % Attributes will be written in closeFile

            % 3.1. Sinusoidal.
            % Patch for matlab 2021. For matlab 2022 can use
            % myRR.ProjectedCRS.GeographicCRS.Spheroid.Radius
            % rather than
            % modisData.projection.modisSinusoidal.geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey   @todo
            attribute = struct(...
                'grid_mapping_name', 'sinusoidal', ...
                'false_easting', params.FalseEasting, ...
                'false_northing', params.FalseNorthing, ...
                'longitude_of_projection_origin', params.LongitudeOfNaturalOrigin, ...
                'longitude_of_central_meridian', 0, ...
                'long_name', 'Sinusoidal projection definition', ...
                'longitude_of_prime_meridian', 0, ...
                'semi_major_axis', modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
                'inverse_flattening', 0, ...
                'proj4', modisData.projection.modisSinusoidal.proj4, ...
                'spatial_ref', modisData.projection.modisSinusoidal.wkt2, ...
                'crs_wkt', modisData.projection.modisSinusoidal.wkt2, ...
                'GeoTransform', GeoTransform ...
                );

            varid = netcdf.defVar(obj.ncid, 'sinusoidal', 'NC_CHAR', []);
            netcdf.endDef(obj.ncid);

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                   fNames{i}, attribute.(fNames{i}));
            end

%{
            % 3.2. Crs.
            attribute = struct( ...
                'grid_mapping_name', 'sinusoidal', ...
                'longitude_of_projection_origin', ...
                params.LongitudeOfNaturalOrigin, ...
                'earth_radius', ...
                modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
                'false_easting', params.FalseEasting, ...
                'false_northing', params.FalseNorthing, ...
                'GeoTransform', GeoTransform, ...
                'proj4', modisData.projection.modisSinusoidal.proj4, ...
                'wkt', modisData.projection.modisSinusoidal.wkt ...
                );
            attribute = struct(...
            'grid_mapping_name', 'sinusoidal', ...
            'longitude_of_projection_origin', ...
            params.LongitudeOfNaturalOrigin, ...
            'earth_radius', ...
            modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
            'false_easting', params.FalseEasting, ...
            'false_northing', params.FalseNorthing, ...
            'GeoTransform', [...
                myRR.XWorldLimits(1), myRR.CellExtentInWorldX, ...
                0.0, ...
                myRR.YWorldLimits(2), 0.0, ...
                -1 * myRR.CellExtentInWorldY], ...
            'proj4', '+proj=sinu +lon_0=0 +x_0=0 +y_0=0 +a=6371007.181 +b=6371007.181 +units=m +no_defs +nadgrids=@null +wktext', ...
            'wkt', "PROJCRS[""MODIS Sinusoidal"",BASEGEOGCRS[""User"",DATUM[""World Geodetic Survey 1984"",SPHEROID[""Authalic_Spheroid"",6371007.181,0.0]],PRIMEM[""Greenwich"",0.0],UNIT[""Degree"",0.0174532925199433]],PROJECTION[""Sinusoidal""],PARAMETER[""False_Easting"",0.0],PARAMETER[""False_Northing"",0.0],PARAMETER[""Central_Meridian"",0.0],UNIT[""Meter"",1.0]]" ...
            );
            varid = netcdf.defVar(obj.ncid, 'crs', 'NC_INT', []);
            netcdf.endDef(obj.ncid);

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                    fNames{i}, attribute.(fNames{i}));
            end
%}

            % 4. Other date metadata and close file.
            % ACDD: ISO 8601:2004: YYYY-MM-DDThh:mm:ss<zone>
            nowStr = datetime('now', 'TimeZone', 'UTC', 'Format', ...
                'yyyy-MM-dd HH:mm:SSxxxxx');
            nowStr = strrep(char(nowStr), ' ', 'T');
            varid = netcdf.getConstant('GLOBAL');
            netcdf.putAtt(obj.ncid, varid, 'date_created', nowStr);
            netcdf.putAtt(obj.ncid, varid, 'date_modified', nowStr);

            netcdf.close(obj.ncid);
            fprintf('%s: wrote %s\n', mfilename(), obj.netCDFFilePath);
        end
        function obj = createFile(obj, netCDFFilePath)
            % Updates the current object by adding id and properties and
            % creating the physical file netCDFFilePath with globalAttribute attributes.
            %
            % Parameters
            % ----------
            % netCDFFilePath: char. Filepath of the netcdf file which will contain the
            %   data.
            %
            % Return
            % obj: ESPNetCDF obj. The updated ESPNetCDF object.
            %
            % C API syntax to Matlab netcdf low-level:
            % https://www.mathworks.com/help/matlab/import_export/
    	    % map-netcdf-api-syntax-to-matlab-syntax.html
            %
            % NetCDF best practices:
            % https://docs.unidata.ucar.edu/nug/current/best_practices.html
            %
            % great resource, includes DIWG recommendations:
            % https://unidata.github.io/python-training/workshop/CF%20Conventions/netcdf-and-cf-the-basics/#gridded

            try
        	    % CLOBBER allows overwrite
        	    % NetCDF4 is for 4 instead of 3
        	    cmode = bitor(netcdf.getConstant('CLOBBER'), ...
                    netcdf.getConstant('NETCDF4'));

        	    % make a template file with unchanging global metadata
                if isfile(netCDFFilePath)
                    delete(netCDFFilePath); % We need to delete the file before creating it.
                end
        	    obj.ncid = netcdf.create(netCDFFilePath, cmode);
                obj.addGlobalAttributes(obj.globalAttribute);

            catch e
                if obj.ncid
                    netcdf.close(obj.ncid);
                end
                rethrow(e);
            end

            % Save the filename for additional operations
            obj.netCDFFilePath = netCDFFilePath;
        end
        function obj = setCoordinateVars(obj)
            % Defines coordinate variables for the region (tile only).

            % 1. Get the reference and projection/geographic properties attached to the
            % region.
            modisData = obj.region.espEnv.modisData;
            myRR = obj.region.getMapCellsReference();
            nrows = myRR.RasterSize(1);
            ncols = myRR.RasterSize(2);

            % 2. Calculate center of UL cell.
            ULx_m = myRR.XWorldLimits(1) + (myRR.CellExtentInWorldX / 2.);
            ULy_m = myRR.YWorldLimits(2) - (myRR.CellExtentInWorldY / 2.);

            % 3. Calculate the overall x and y projected range.
            ntilecols = modisData.sensorProperties.tiling.columnCount;
            ntilerows = modisData.sensorProperties.tiling.rowCount;
            x_extent_m = ntilecols * ncols * myRR.CellExtentInWorldX;
            y_extent_m = ntilerows * nrows * myRR.CellExtentInWorldY;
            x_valid_range = [ -1 * x_extent_m / 2, x_extent_m / 2 ];
            y_valid_range = [ -1 * y_extent_m / 2, y_extent_m / 2 ];

            % 4. Define the dimension variables: time, x, y.
            time_dimID = netcdf.defDim(obj.ncid, 'time', ...
                netcdf.getConstant('NC_UNLIMITED'));
            x_dimID = netcdf.defDim(obj.ncid, 'x', ncols);
            y_dimID = netcdf.defDim(obj.ncid, 'y', nrows);

            % 5. Define the time attributes.
            time_varID = netcdf.defVar(obj.ncid, 'time', 'NC_DOUBLE', ...
                time_dimID);
            netcdf.putAtt(obj.ncid, time_varID, 'standard_name', 'time');
            netcdf.putAtt(obj.ncid, time_varID, 'calendar', 'standard');
            netcdf.putAtt(obj.ncid, time_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, time_varID, 'long_name', 'ANSI date');
            netcdf.putAtt(obj.ncid, time_varID, 'units', ...
                sprintf('days since %s', ...
                datestr(obj.epochDt, 'yyyy-mm-dd HH:MM:SS')));
            netcdf.putAtt(obj.ncid, time_varID, 'axis', 'T');
            netcdf.putAtt(obj.ncid, time_varID, 'valid_range', ...
                [0., realmax]);

            % 6. Define the x and y attributes.
            x_varID = netcdf.defVar(obj.ncid, 'x', 'NC_DOUBLE', x_dimID);
            netcdf.putAtt(obj.ncid, x_varID, 'standard_name', ...
                'projection_x_coordinate');
            netcdf.putAtt(obj.ncid, x_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, x_varID, 'long_name', 'x');
            netcdf.putAtt(obj.ncid, x_varID, 'units', 'meters');
            netcdf.putAtt(obj.ncid, x_varID, 'axis', 'X');
            netcdf.putAtt(obj.ncid, x_varID, 'valid_range', x_valid_range);

            y_varID = netcdf.defVar(obj.ncid, 'y', 'NC_DOUBLE', y_dimID);
            netcdf.putAtt(obj.ncid, y_varID, 'standard_name', ...
                'projection_y_coordinate');
            netcdf.putAtt(obj.ncid, y_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, y_varID, 'long_name', 'y');
            netcdf.putAtt(obj.ncid, y_varID, 'units', 'meters');
            netcdf.putAtt(obj.ncid, y_varID, 'axis', 'Y');
            netcdf.putAtt(obj.ncid, y_varID, 'valid_range', y_valid_range);

            % 7. End define mode before populating variable data
            netcdf.endDef(obj.ncid);

            % 8. Populate x and y (time will be populated with actual data)
            netcdf.putVar(obj.ncid, x_varID, ...
                ULx_m + (myRR.CellExtentInWorldX * (0:(ncols - 1))));
            netcdf.putVar(obj.ncid, y_varID, ...
                ULy_m - (myRR.CellExtentInWorldY * (0:(nrows - 1))));
        end
        function obj = setDate(obj, thisDate)
            % Defines the date for data in the file. NB: there's only one date per file.
            %
            % Parameters
            % ----------
            % thisDate : datetime.

            % Convert thisDate to days since epoch.
            seconds_per_day = 24 * 60 * 60;
            time_varID = netcdf.inqVarID(obj.ncid, 'time');
            netcdf.putVar(obj.ncid, time_varID, 0, ...
                double(convertTo(thisDate, 'epochtime', ...
                'Epoch', string(obj.epochDt))) / seconds_per_day );

        end
        function obj = setGlobalAttributes(obj)
            % Defines object static and runtime global attributes

            % Set static global attributes
            obj.globalAttribute = obj.defaultGlobalAttribute;

            % Add runtime global attributes
            obj.globalAttribute.product_version = ...
                obj.region.espEnv.modisData.versionOf.VariablesNetCDF;
            obj.globalAttribute.citation = replace(obj.globalAttribute.citation, ...
                '{product_version}', obj.globalAttribute.product_version);
            [~, currentGitHash] = system('git rev-parse --short HEAD');
            obj.globalAttribute.software_version_id = ...
                erase(currentGitHash, newline);
        end
        function obj = setVariable(obj, var, ...
                varName, varType, attribute)
            % Sets a new variable in the file
            % var : data to populate
            % varName : name of variable to populate
            % varType : variable type
            % attribute : 2xN cell array with 'attribute', value for each
            %     of N attributes
            % Note that valid_range, valid_min, valid_max and
            % _FillValue data values must be same type as var

            time_dimID = netcdf.inqDimID(obj.ncid, 'time');
            x_dimID = netcdf.inqDimID(obj.ncid, 'x');
            y_dimID = netcdf.inqDimID(obj.ncid, 'y');

            %varID = netcdf.defVar(obj.ncid, varName, ...
            %    varType, [time_dimID y_dimID x_dimID]);
            varID = netcdf.defVar(obj.ncid, varName, ...
                varType, [x_dimID y_dimID time_dimID]);
            theseFieldnames = fieldnames(attribute);
            for i = 1:length(theseFieldnames)
                thisFieldName = theseFieldnames{i};
                if strcmp(thisFieldName, 'FillValue')
                    thisFieldName = '_FillValue';
                end
                netcdf.putAtt(obj.ncid, varID, ...
                   thisFieldName, attribute.(theseFieldnames{i}));
            end

            % Turn on compression
            doShuffle = true;
            doDeflate = true;
            deflateLevel = 1;
            netcdf.defVarDeflate(obj.ncid, varID, ...
                doShuffle, doDeflate, deflateLevel);

            % End define mode before populating variable data
            netcdf.endDef(obj.ncid);

            netcdf.putVar(obj.ncid, varID, ...
                reshape(var', 1, size(var,2), size(var,1)));
        end
    end
    methods(Static)
%{
        function mosaicToNetCDF(matFilePath, bigRegionName, tileRegion, ...
                netCDFFilePath)
            % NB: developed but not sure it will be used.                    @deprecated
            % Make an STC tileID .nc file from the input mosaic matFilePath
            tileID = tileRegion.regionName;
            espEnv = tileRegion.espEnv;

            % TBD: parse inputs
            fprintf('%s: Mosaic file: %s\n', mfilename(), matFilePath);
            fprintf('%s: bigRegionName: %s\n', mfilename(), bigRegionName);
            fprintf('%s: tileID: %s\n', mfilename(), tileID);
            fprintf('%s: .nc file: %s\n', mfilename(), netCDFFilePath);

            % Create/populate the generic metadata for a v2023.1 file
            version = 'v2023.1';
            versionLabel = replace(version, '.', '_');

            % Create/populate the NetCDF file metadata
            thisNetCDF = ESPNetCDF(tileRegion, version = version);
            thisNetCDF = thisNetCDF.createFile(netCDFFilePath);
            thisNetCDF = thisNetCDF.setCoordinateVars();

            data = load(matFilePath, 'dateval');
            thisNetCDF = thisNetCDF.setDate(...
                datetime(data.dateval, 'ConvertFrom', 'datenum'));

            % Figure out the row/col subset for the requested tileID
            % in the input mosaic--I think Sebastien has a function for
            % this in the new main branch that we can use instead of
            % hardcoding here
            % I'm hardcoding this for now using bigRegionName and tileID
            if strcmp(bigRegionName,'westernUS')

                % westernUS
                s.h08v04 = {1,2400,1,2400};
                s.h08v05 = {2401,4800,1,2400};
                s.h09v04 = {1,2400,2401,4800};
                s.h09v05 = {2401,4800,2401,4800};
                s.h10v04 = {1,2400,4801,7200};

            elseif strcmp(bigRegionName, 'USAlaska')

        	    % Alaska
                s.h07v03 = {4801,7200,1,2400};
                s.h08v03 = {4801,7200,2401,4800};
                s.h09v02 = {2401,4800,4801,7200};
                s.h09v03 = {4801,7200,4801,7200};
                s.h10v02 = {2401,4800,7201,9600};
                s.h10v03 = {4801,7200,7201,9600};
                s.h11v02 = {2401,4800,9601,12000};
                s.h11v03 = {4801,7200,9601,12000};
                s.h12v01 = {1,2400,12001,14400};
                s.h12v02 = {2401,4800,12001,14400};
                s.h13v01 = {1,2400,14401,16800};
                s.h13v02 = {2401,4800,14401,16800};

            else

                ME = MException('ESPNetCDF:inputError', ...
                    '%s: invalid bigRegionName %s', ...
                    mfilename(), bigRegionName);
                throw(ME)

            end

            rowStart = s.(tileID){1};
            rowStop = s.(tileID){2};
            colStart = s.(tileID){3};
            colStop = s.(tileID){4};

            % Add variable data from the .mat file
            availableVariables = espEnv.myConf.variable(...
                find(espEnv.myConf.variable.(['write_netCDF_' versionLabel]) == 1), :);
            nVars = size(availableVariables, 1);
            for var = 1:nVars
                rec = availableVariables(var, :);
                data = load(matFilePath, rec.('output_name'){1}, ...
                    [rec.('output_name'){1} '_divisor']);

                % Subset the large variable mosaic array
                % to the tileID coords
                data.(rec.('output_name'){1}) = ...
                    data.(rec.('output_name'){1})( ...
                    rowStart:rowStop, colStart:colStop);

        	    % Make 2 x N cell array with attributes and values
                % Ensure _FillValue and valid_range are correct type
                attribute = {...
                    'long_name', rec.('netCDF_long_name'){1}; ...
                    'standard_name', rec.('netCDF_standard_name'){1}; ...
                    'units', rec.('netCDF_units'){1}; ...
                    '_FillValue', ...
                    cast(rec.('nodata_value'), ...
                    ESPNetCDF.matClass(rec.('netCDF_type'){1})); ...
                    'valid_range', ...
                    cast([rec.('min') rec.('max')], ...
                    ESPNetCDF.matClass(rec.('netCDF_type'){1})); ...
                    'description', rec.('netCDF_description'){1}};
        	    thisNetCDF = ...
                    thisNetCDF.setVariable(data.(rec.('output_name'){1}), ...
                    rec.('netCDF_varName'){1}, rec.('netCDF_type'){1}, ...
                    attribute);
            end

            % Add a few more global attributes from the .mat file
            % that we want to carry along into the .nc file
            data = load(matFilePath, 'mindays', 'zthresh', 'stcStruct', ...
                'files');
            for i=1:numel(data.zthresh)
                zthresh(i) = strjoin(string(data.zthresh{i}));
            end
            attribute = struct(...
            'mindays', strjoin(string(data.mindays), ', '),...
            'zthresh', strjoin(zthresh,', '));
            fNames = fieldnames(data.stcStruct);
            for i = 1:length(fNames)
                if 1 == numel(data.stcStruct.(fNames{i}))
                    attribute.(['STC_', fNames{i}]) = ...
                        string(data.stcStruct.(fNames{i}));
                else
                    attribute.(['STC_', fNames{i}]) = ...
                        strjoin(string(data.stcStruct.(fNames{i})), ', ');
                end
            end
            for i=1:size(data.files, 1)
                if strcmp(data.files{i, 1}, tileID)
                    attribute.STC_file = data.files{i, 2};
                end
            end
            thisNetCDF.addGlobalAttributes(attribute);

            % Write it out
            thisNetCDF.closeFile();

        end
%}
        function generateNetCDFFromRegionAndMatFile(region, thisDate, ...
            matFilePath, netCDFFilePath)
            % Get information from a .mat file for a region and write them
            % in a CF-compliant netCDF file (classic NetCDF-4) with the projection
            % MODIS Sinusoidal correctly set (a tricky part!).
            %
            % Parameters
            % ----------
            % region: Region obj. Only tile.
            % thisDate: datetime.
            % matFilePath: char. Filepath of the .mat file to be published in netcdf.
            % netCDFFilePath: char. Filepath of the generated .nc netcdf file.

            % 1. Initialize the ESPNetCDF object and create the files with basics
            %attributes.
            logger = Logger('netcdf');
            fprintf('%s: Start generating .nc %s from .mat %s.\n', mfilename(), ...
                netCDFFilePath, matFilePath);

            % Create/populate the NetCDF file metadata
            thisNetCDF = ESPNetCDF(region, thisDate);
            thisNetCDF = thisNetCDF.createFile(netCDFFilePath);
            try
                thisNetCDF = thisNetCDF.setCoordinateVars();
                thisNetCDF = thisNetCDF.setDate(thisDate);

                % 2. Add variables, their values and attributes.
                availableVariables = region.espEnv.myConf.variable(...
                    find(region.espEnv.myConf.variable.( ...
                    ['write_netCDF_', ...
                        replace(region.espEnv.modisData.versionOf.VariablesNetCDF, ...
                        '.', '_')]) == 1), :);
                for varIdx = 1:size(availableVariables, 1)
                    varConf = availableVariables(varIdx, :);
                    data = load(matFilePath, varConf.('output_name'){1}, ...
                        [varConf.('output_name'){1} '_divisor']);
                    divisor = data.([varConf.('output_name'){1} '_divisor']);
                    % Handle divisor that is not trivial (and adjust type)
                    % This is special case for v2022.0 albedo variable
                    if divisor ~= 1
                        data.(varConf.('output_name'){1}) = ...
                            cast(...
                            data.(varConf.('output_name'){1}) / double(divisor), ...
                            ESPNetCDF.matClass(varConf.('netCDF_type'){1}));
                    end

                    % Attributes for this variable and the values.
                    attribute = struct(...
                        long_name = varConf.('netCDF_long_name'){1}, ...
                        units = varConf.('netCDF_units'){1}, ...
                        FillValue = ...
                            cast(varConf.('nodata_value'), ...
                            ESPNetCDF.matClass(varConf.('netCDF_type'){1})), ...
                        valid_range = ...
                            cast([varConf.('min') varConf.('max')], ...
                            ESPNetCDF.matClass(varConf.('netCDF_type'){1})), ...
                        description = varConf.('netCDF_description'){1}, ...
                        grid_mapping = 'sinusoidal'); % this grid_mapping references the
                            % general grid_mapping and wasn't present in the first versions
                            % of this script (before 2023-08-31).
                    if ~strcmp(varConf.('netCDF_standard_name'){1}, 'none')
                        attribute.standard_name = varConf.('netCDF_standard_name'){1};
                    end
                    if strcmp(varConf.('output_name'){1}, ...
                        'viewable_snow_fraction_status')
                        attribute.flag_values = cast( ...
                            cell2mat(struct2cell(Variables.dataStatus))', ...
                            ESPNetCDF.matClass(varConf.('netCDF_type'){1}));
                        attribute.flag_meanings = strjoin(fieldnames( ...
                            Variables.dataStatus ));
                    end

                    thisNetCDF = thisNetCDF.setVariable( ...
                        data.(varConf.('output_name'){1}), ...
                        varConf.('netCDF_varName'){1}, varConf.('netCDF_type'){1}, ...
                        attribute);
                end

                % 3. Add a few more global attributes from the .mat file
                % that we want to carry along into the .nc file.
                attribute = struct();
                % Dates and duration in ISO8601. We arbitrarily set the start time to
                % UTC (Z) midnight although it's not, and duration to 1 day.
                attribute.time_coverage_start = string( ...
                    datetime(year(thisDate), month(thisDate), day(thisDate), ...
                    0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ');
                attribute.time_coverage_end = string( ...
                    datetime(year(thisDate), month(thisDate), day(thisDate) + 1, ...
                    0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ');
                attribute.time_coverage_duration = 'P0Y0M1DT0H0M0S';

                attribute.versionOf_SCAGDRFSSTC = ...
                    region.espEnv.modisData.versionOf.SCAGDRFSSTC;
                attribute.versionOf_VariablesMatlab = ...
                    region.espEnv.modisData.versionOf.VariablesMatlab;
                attribute.versionOf_VariablesNetCDF = ...
                    region.espEnv.modisData.versionOf.VariablesNetCDF;
                fieldNamesInMat = fieldnames(matfile(matFilePath));
                matWantedAttributeNames = {'files', 'stcStruct'};
                    % I didn't put 'mindays', 'zthresh' wich are already in stcStruct.

                % NB: it's probably required to have clearer names for metadata        @todo
                versionNetCDFString = replace( ...
                    attribute.versionOf_VariablesNetCDF, '.', '_');
                for matWantedAttributeNameIdx = 1:length(matWantedAttributeNames)
                    matWantedAttributeName = ...
                        matWantedAttributeNames{matWantedAttributeNameIdx};
                    % We load the metadata only if there's no default value.
                    if ismember(versionNetCDFString, ...
                        fieldnames(thisNetCDF.defaultAttributeValues)) & ...
                        ismember(matWantedAttributeName, ...
                        fieldnames(thisNetCDF.defaultAttributeValues. ...
                            (versionNetCDFString)))
                        data = thisNetCDF.defaultAttributeValues. ...
                            (versionNetCDFString).(matWantedAttributeName);
                    else
                        data = load(matFilePath, ...
                            matWantedAttributeName).(matWantedAttributeName);
                    end
                    switch matWantedAttributeName
                        case 'files'
                            [~, stcFileName, stcFileExt] = fileparts(data{1,2});
                            attribute.STC_file = sprintf('%s%s', stcFileName, stcFileExt);
    %{
                        case {'zthresh', 'mindays'}
                            attribute.(['STC_', matWantedAttributeName])  = strjoin( ...
                                string(data{1}));
    %}
                        case 'stcStruct'
                            theseFieldNames = fieldnames(data);
                            for fieldIdx = 1:length(theseFieldNames)
                                if 1 == numel(data.(theseFieldNames{fieldIdx}))
                                    attribute.(['STC_', theseFieldNames{fieldIdx}]) = ...
                                        string(data.(theseFieldNames{fieldIdx}));
                                else
                                    attribute.(['STC_', theseFieldNames{fieldIdx}]) = ...
                                        strjoin( ...
                                            string(data.(theseFieldNames{fieldIdx})), ...
                                            ', ');
                                end
                            end
                    end
                end
                thisNetCDF.addGlobalAttributes(attribute);

                % 5. Write it out.
                thisNetCDF.closeFile();
                logger.printDurationAndMemoryUse(dbstack);
                fprintf('%s: Done generating .nc %s from .mat %s.\n', mfilename(), ...
                    netCDFFilePath, matFilePath);
            catch ME
                netcdf.close(thisNetCDF.ncid);
                rethrow(ME);
            end
        end

	% TBD: we need a function that will make an .nc file from
	% input data instead of from one of the legacy .mat files
    end
end
