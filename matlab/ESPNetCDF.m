classdef ESPNetCDF < handle
    % ESPNetCDF - class for writing ESP data related to a region to NetCDF-CF files
    % Projection MODIS Sinusoidal only.
    % NB: only works with modis tiles 2023-08-31.
    
    % IMPORTANT: This class uses sample .nc files stored in template/. These files
    %   need to be edited and generated following docs/user_guideV/output_netcdf.md
    %
    % Use case
    % --------
%{
    addpath(genpath(getenv('matlabPathForESPToolbox')));
    label = 'v2022.0'; versionOfAncillary = 'v3.2'; % for v03 HMA ASHimalaya.
    label = 'v2024.0d'; versionOfAncillary = 'v3.1';
    label = 'v2023.0e'; versionOfAncillary = 'v3.1'; % for STC western US v2023.hist.
    inputProduct = 'mod09ga';
    inputProductVersion = '061';
    if strcmp(label, 'v2023.0e')
        %label = 'v2023.1';
        % versionOfAncillary = 'v3.1';
        regionName = 'h08v05';
        thisDate = datetime(2023, 1, 1);
        outputDataLabel = 'daacnetcdfv2023hist';
    elseif strcmp(label, 'v2022.0')
        label = 'v03';
        versionOfAncillary = 'v3.2';
        modisData.versionOf.VariablesNetCDF = 'v2022.0';
        regionName = 'h23v05';
        thisDate = datetime(2022, 4, 2);
        outputDataLabel = 'daacnetcdfv20220';
    elseif strcmp(label, 'v2024.0d')
        label = 'v2024.0d'; versionOfAncillary = 'v3.1';
        regionName = 'h08v05';
        thisDate = datetime(2024, 1, 1);
        outputDataLabel = 'VariablesNetCDF';
    end
    modisData = MODISData(label = label, versionOfAncillary = versionOfAncillary, ...
          inputProduct = inputProduct, inputProductVersion = inputProductVersion);
    if strcmp(label, 'v03')
        modisData.versionOf.(outputDataLabel) = 'v03'; %'v2022.0';
    elseif strcmp(label, 'v2023.0e')
      modisData.versionOf.(outputDataLabel) = 'v2023.hist';
    end
    espEnv = ESPEnv(modisData = modisData, scratchPath = getenv('espScratchDir'));
    region = Regions(regionName, [regionName, '_mask'], espEnv, modisData);
    matFilePath = espEnv.getFilePathForDateAndVarName(regionName, 'VariablesMatlab', ...
        thisDate, '', '');
    netCDFFilePath = espEnv.getFilePathForDateAndVarName(regionName, ...
        outputDataLabel, thisDate, '', '');
    ESPNetCDF.generateNetCDFFromRegionAndMatFile(region, thisDate, matFilePath, ...
        netCDFFilePath);
%}
%{
    % Snippet to dump the netcdf info
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    thisFileName = 'HMA2_MODSTC_h23v05_20220402_v01.0.nc';
    thisFilePath = [getenv('espScratchDir'), ...
      'modis_archive/hma2_modstc_v03/h23v05/2022/', thisFileName];
    thisFilePath = [getenv('espScratchDir'), ...
      'modis/variables/scagdrfs_netcdf_v2022.0/v006/h23v05/', ...
      '2022/h23v05_Terra_20220402.v2022.0.nc'];
    thisFileName = 'mod09ga_061_spi_h08v05_20240101.v2024.hist.nc';
    thisFilePath = ['/scratch/alpine/sele7124/mod09ga.061/spires/v2024.hist/output/netcdf/h08v05/2024/', thisFileName];  
    text = jsonencode(ncinfo(thisFilePath), "PrettyPrint", true);
    text = replace(text, {'%'}, {'%%'});
    fileID = fopen([thisFileName, '.json'], 'w');
    fprintf(fileID, text);
    fclose(fileID);
%}
    properties
        globalAttribute      % global attributes to write
        ncid           % NetCDF fileID
        netCDFFilePath     % NetCDF file to write
        grid_mapping   % name of CF variable with projection information
        region         % Region obj.
        thisDate    % datetime. Date of the data saved in the file.
    end
    properties(Constant)
        epochDt = datetime('2000-01-01 00:00:00');
        defaultGlobalAttribute = struct(...
            title = ['MODIS/Terra L3 Global Daily 500m Sinusoidal ', ...
            'Spatially and Temporally Complete (STC) Snow Cover and ', ...
            'Snow Surface Properties'], ...
            Conventions = 'CF-1.10, ACDD-1.3', ...
            source = ['MOD09GA Terra Collection 6, includes v006 and ', ...
            '(beginning 28 Dec 2021) v061 files'], ...
            standard_name_vocabulary = 'CF Standard Name Table (v82,Â 06 July 2023)', ...
            summary = ['This data set contains spatially and temporally ', ...
            'complete (STC) raster images of snow cover and snow ', ...
            'surface properties derived from MODSCAG and MODDRFS. ', ...
            'STC improvements include cloud detection, off-nadir ', ...
            'viewing and adjustment for snow occluded by forests ', ...
            'from the satellite.'], ...
            history = 'Produced by ESPToolbox.', ...
            comment = ['Stillinger et al. (2023) used for snow cover ', ...
            'validation with 3 m airborne snow maps; ', ...
            'Rittger et al. (2021) used for application and comparison ', ...
            'of Landsat 8, MODIS, and VIIRS; ', ...
            'Rittger et al. (2020) used for gap filling procedure ', ...
            'for snow cover (also used on other variables); ', ...
            'Bair et al. (2019) used for albedo validation with 3 ', ...
            'in-situ stations; ', ...
            'Rittger et al. (2013) used for Landsat 5 and 7 comparison ', ...
            'to MODSCAG and MOD10A1 binary and fractional; ', ...
            'Painter et al. (2012) used for MODDRFS algorithm; ', ...
            'Painter et al. (2009) used for MODSCAG algorithm; ', ...
            'Dozier et al. (2008) used for interpolation and off-nadir ', ...
            'weighting of observations. ', ...
            'Code: https://github.com/sebastien-lenard/snow-today. ', ...
            'File downloaded from: ftp://dtn.rc.colorado.edu/shares/snow-today.'], ...
            references = ['Stillinger, T., K. Rittger, M.S. Raleigh, ', ...
            'A. Michell, R.E. Davis, and E.H. Bair. 2023. Landsat, ', ...
            'MODIS, and VIIRS snow cover mapping algorithm performance ', ...
            'as validated by airborne lidar datasets. The Cryosphere ', ...
            '17: 567-590, doi:10.5194/tc-17-567-2023. ' newline, ...
            'Rittger, K., K. J. Bormann, E. H. Bair, J. Dozier, and ', ...
            'T. H. Painter. 2021. Evaluation of VIIRS and MODIS Snow ', ...
            'Cover Fraction in High-Mountain Asia Using Landsat 8 OLI. ', ...
            'Frontiers in Remote Sensing, 2 (8). ', ...
            'doi:10.3389/frsen.2021.647154. ' newline, ...
            'Rittger, K., M. S. Raleigh, J. Dozier, A. F. Hill, ', ...
            'J. A. Lutz, and T. H. Painter. 2020. Canopy Adjustment ', ...
            'and Improved Cloud Detection for Remotely Sensed Snow Cover ', ...
            'Mapping. Water Resources Research, 55. ', ...
            'doi:10.1029/2019WR024914. ' newline, ...
            'Bair, E. H., K. Rittger, S. M. Skiles, and J. Dozier. 2019. ', ...
            'An Examination of Snow Albedo Estimates From MODIS and ', ...
            'Their Impact on Snow Water Equivalent Reconstruction. ', ...
            'Water Resources Research, 55, 7826-7842, ', ...
            'doi:10.1029/2019wr024810. ' newline, ...
            'Rittger, K., T. H. Painter, and J. Dozier. 2013. ', ...
            'Assessment of methods for mapping snow cover from MODIS. ', ...
            'Advances in Water Resources, 51, 367-380, ', ...
            'doi:10.1016/j.advwatres.2012.03.002. ' newline, ...
            'Painter, T. H., A. C. Bryant, and S. M. Skiles. 2012. ', ...
            'Radiative forcing by light absorbing impurities in snow ', ...
            'from MODIS surface reflectance data. Geophysical ', ...
            'Research Letters, 39, L17502, ', ...
            'doi:10.1029/2012gl052457. ' newline, ...
            'Painter, T. H., K. Rittger, C. McKenzie, P. Slaughter, ', ...
            'R. E. Davis, and J. Dozier. 2009. Retrieval of subpixel ', ...
            'snow covered area, grain size, and albedo from MODIS. ', ...
            'Remote Sensing of Environment, 113(4): 868-879. ', ...
            'doi:10.1016/j.rse.2009.01.001. ' newline, ...
            'Dozier, J., T. H. Painter, K. Rittger, and J. E. Frew. ', ...
            '2008. Time-space continuity of daily maps of fractional ', ...
            'snow cover and albedo from MODIS. Advances in Water ', ...
            'Resources, 31(11): 1515-1526. ', ...
            'doi:10.1016/j.advwatres.2008.08.011. '], ...
            publisher_institution = 'Institute for Arctic and Alpine Research', ...
            publisher_name = 'Institute for Arctic and Alpine Research', ...
            publisher_type = 'institution', ...
            publisher_url = 'https://nsidc.org/snow-today', ...
            publisher_email = 'snow-today@nsidc.org', ...
            acknowledgement = ['These data are produced and ', ...
            'supported by the Institute of Arctic and Alpine ', ...
            'Research. The data products were produced with funding ', ...
            'from NASA grants 80NSSC18K0427, 80NSSC20K1721, ', ...
            '80NSSC22K0703, 80NSSC22K0929, 80NSSC18K1489, ', ...
            '80NSSC20K1349. This work utilized ', ...
            'the Alpine high performance computing resource at the ', ...
            'University of Colorado Boulder. Alpine is jointly ', ...
            'funded by the University of Colorado Boulder, the ', ...
            'University of Colorado Anschutz, and Colorado State ', ...
            'University. Data storage supported by the University ', ...
            'of Colorado Boulder PetaLibrary.'], ...
            license = ['Creative Commons BY 4.0. You are free to (1) share: copy and redistribute the material in any medium or format for any purpose, even commercially; (2) Adapt: remix, transform, and build upon the material for any purpose, even commercially; Under the following terms, (3) Attribution: You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. https://creativecommons.org/licenses/by/4.0/.'], ...
            creator_name = 'Karl Rittger', ...
            creator_url = 'https://www.colorado.edu/instaar/karl-rittger', ...
            creator_email = 'karl.rittger@colorado.edu', ...
            contributor_name = ['Karl Rittger, Mary J. Brodzik, ', ...
            'Sebastien J. P. Lenard, Ross T. Palomaki, Jessica Calme'], ...
            contributor_role = ['principal_investigator, developer, ', ...
            'research_scientist, postdoc, data_manager'], ...
            citation = ['Rittger, K., M. J. Brodzik, S. J. P. Lenard, ', ...
                'Ross T. Palomaki, T. Stillinger, E. H. Bair, J. Dozier and ', ...
                'T. H. Painter. 2023. ', ...
                'MODIS/Terra L3 Global Daily 500m Sinusoidal ', ...
                'Spatially and Temporally Complete (STC) Snow Cover ', ...
                'and Snow Surface Properties, Version ', ...
                '{product_version}', ...
                ' INSTAAR, Boulder, CO, USA. Digital Media. ', ...
                'https://github.com/sebastien-lenard/snow-today. ', ...
                'ftp://dtn.rc.colorado.edu/shares/snow-today']);
%{
            % Before 20241126:
            Was license = ['Access Constraint: These data are freely, ', ...
            'openly, and fully accessible; ', ...
            'Use Constraint: These data are freely, openly, and fully ', ...
            'available to use without restrictions, provided that you ', ...
            'cite the data according to the recommended citation ', ...
            'included here.'], ...
%}
            % NB: Citation included at the end :
            % 'ftp://dtn.rc.colorado.edu/shares/snow-today, doi:TO UPDATE'
            % but removed because ftp doesn't work and doi unavailable.
            % NB: The properties also included: id = 'DOI TO UPDATE'
            % but removed because doi unavailable.
            %
            % TODO: add back these fields when the values will be available!
            %                                                                      @todo
            %                                                                 @important
        v2022_0Attribute = struct(...
            contributor_name = ['Karl Rittger, Mary J. Brodzik, ', ...
                'Sebastien J. P. Lenard, Ross T. Palomaki, Edward H. Bair, ', ...
                'Thomas H. Painter'], ...
            contributor_role = ['principal_investigator, developer, ', ...
                'research_scientist, postdoc, researcher, researcher'], ...
            citation = ['Rittger, K., M. J. Brodzik, S. J. P. Lenard, ', ...
                'Ross T. Palomaki, E. H. Bair and ', ...
                'T. H. Painter. 2023. ', ...
                'High Mountain Asia MODIS/Terra L3 Daily 500m SIN Grid', ...
                ' Spatially and Temporally Complete (STC) Snow Cover and Snow', ...
                ' Surface Properties, Version 1.', ...
                ' INSTAAR, University of Colorado, Boulder, CO, USA. ', ...
                ' Digital Media. ', ...
                'https://github.com/sebastien-lenard/snow-today. ', ...
                'ftp://dtn.rc.colorado.edu/shares/snow-today. ', ...
                'doi:10.5067/9FYZPP9AIV7G'], ...
            comment = ['Depending on use, the user may filter the data by ', ...
            'discarding pixels having a snow cover fraction below 15 percent. ', ...
            'The user may also apply additional ', ...
            'masks to this dataset: (1) water bodies; (2) dry lakes; ', ...
            '(3) an elevation mask calculated ', ...
            'across the full High Mountain Asia STC dataset and varying ', ...
            'linearly from 2,000 m at the bottom of tile h23v06 to 0 m at the top ', ...
            'of tile h23v04. Please refer documentation for suggested masks. ', ...
            'The code used to generate the dataset uses the previous work of: ', ...
            'Stillinger et al. (2023) used for snow cover ', ...
            'validation with 3 m airborne snow maps; ', ...
            'Rittger et al. (2021) used for application and comparison ', ...
            'of Landsat 8, MODIS, and VIIRS; ', ...
            'Rittger et al. (2020) used for gap filling procedure ', ...
            'for snow cover (also used on other variables); ', ...
            'Bair et al. (2019) used for albedo validation with 3 ', ...
            'in-situ stations; ', ...
            'Rittger et al. (2013) used for Landsat 5 and 7 comparison ', ...
            'to MODSCAG and MOD10A1 binary and fractional; ', ...
            'Painter et al. (2012) used for MODDRFS algorithm; ', ...
            'Painter et al. (2009) used for MODSCAG algorithm; ', ...
            'Dozier et al. (2008) used for interpolation and off-nadir ', ...
            'weighting of observations. ', ...
            'Code: https://github.com/sebastien-lenard/snow-today.'], ...
            id = '10.5067/9FYZPP9AIV7G', ...
            title = ['High Mountain Asia MODIS/Terra L3 Daily 500m SIN Grid', ...
                ' Spatially and Temporally Complete (STC) Snow Cover and Snow', ...
                ' Surface Properties, Version 1'], ...
            metadata_link = 'https://doi.org/10.5067/9FYZPP9AIV7G');
                % Replacing or new global attributes yielded by NSIDC (Mary Jo).
        % NB: all citations should follow Chicago style, where only the first name is
        % inverted with the family name and last person is preceded by a 'and'.
        % https://www.chicagomanualofstyle.org/book/ed17/part3/ch14/psec076.html
         v2024_0Attribute = struct(...
            source = ['MOD09GA Terra Collection 6 v061'], ...
            summary = ['MODIS/Terra L3 Daily 500m SIN Grid', ...
                ' SPIReS Snow Cover and Snow', ...
                ' Surface Properties, Version 2024.0'], ...
            comment = ['Snow cover validated with 3 m airborne snow maps on ', ...
              '116 days (Stillinger et al., 2023); Snow albedo validated using ', ...
              'terrain correct in-situ observations at 3 sites for ~20 years', ...
              'with spatial comparisons to 31 ASO Inc hyperspectral airborne ', ...
              'flights (Palomaki et al., RSE, in review). Preliminary radiative', ...
              ' forcing evaluation performed at 1 site in the San Juan mountains', ...
              ' of Colorado.'], ...
            contributor_name = ['Karl Rittger, ', ...
                'Sebastien J. P. Lenard, Ross T. Palomaki'], ...
            contributor_role = ['principal_investigator, research_scientist, ', ...
                'research_scientist'], ...
            citation = ['Rittger, K., S. J. P. Lenard ', ...
                'and Ross T. Palomaki. 2024. ', ...
                'MODIS/Terra L3 Daily 500m SIN Grid', ...
                ' SPIRES Snow Cover and Snow', ...
                ' Surface Properties, Version 2024.0. ', ...
                ' INSTAAR, University of Colorado, Boulder, CO, USA. ', ...
                ' Digital Media. ', ...
                'https://github.com/sebastien-lenard/snow-today. ', ...
                'ftp://dtn.rc.colorado.edu/shares/snow-today.'], ...
            id = 'X', ...
            title = ['MODIS/Terra L3 Daily 500m SIN Grid', ...
                ' SPIReS Snow Cover and Snow', ...
                ' Surface Properties, Version 2024.0'], ...
            metadata_link = 'X', ...
            references = ['Bair, E.H., T. Stillinger, and J. Dozier. 2021. ', ...
            'Snow Property Inversion from Remote Sensing (SPIReS): ', ...
            'A generalized multispectral unmixing approach with examples ', ...
            'from MODIS and Landsat 8 OLI. IEEE Transactions on Geoscience ', ...
            'and Remote Sensing 59.9: 7270-7284, doi: 10.1109/TGRS.2020.3040328. https://github.com/edwardbair/SPIRES. ', ...
            'Stillinger, T., K. Rittger, M.S. Raleigh, A. Michell, R.E. Davis, ', ...
            'and E.H. Bair. 2023. Landsat, MODIS, and VIIRS snow cover mapping ', ...
            'algorithm performance as validated by airborne lidar datasets. ', ...
            'The Cryosphere 17: 567-590, doi: 10.5194/tc-17-567-2023. ',...
            'Bair, E. H., A. Abreu Calfa, K. Rittger, and J. Dozier. 2018. Using machine learning for real-time estimates of snow water equivalent in the watersheds of Afghanistan. The Cryosphere 12.5: 1579-1594, doi: 10.5194/tc-12-1579-2018. https://github.com/edwardbair/ParBal. Bair, E. H., K. Rittger, R. E. Davis, T. H. Painter, and Dozier, J. 2016. Validating reconstruction of snow water equivalent in California''s Sierra Nevada using measurements from the NASA Airborne Snow Observatory. Water Resources Research 52, doi: 10.1002/2016WR018704. Rittger, K., Bair, E.H., Kahl, A., and Dozier, J. 2016. Spatial estimates of snow water equivalent from reconstruction. Advances in Water Resources 94: 345-363, doi: 10.1016/j.advwatres.2016.05.015. Vermote, E., and R. Wolfe. 2021. MODIS/Terra Surface Reflectance Daily L2G Global 1km and 500m SIN Grid V061. Distributed by NASA EOSDIS Land Processes Distributed Active Archive Center, doi: 10.5067/MODIS/MOD09GA.061.MODIS.']);
            % Top for spires, mid for Parbal, bottom for mod09ga.
        defaultAttributeValues = struct(v03 = struct(stcStruct = struct( ...
            mindays = 10, zthresh = [800, 800], rawRovDV = [0, 100], ...
            rawRovRF = [0, 400], temporalRovDV = [0, 70], temporalRovRF = [0, 500], ...
            sthreshForGS = 0.3, sthreshForRF = 0.3, minZForNonForestedAdjust = 'n/a', ...
            nonForestedScaleFactor = 'n/a', minSnowForVegAdjust = 'n/a', ...
            canopyToTrunkRatio = 'n/a')), ...
            v2024_0 = struct()); % default values for v03/v2022.0 hard coded
                % because unavailable in mosaic .mat file. Values               @tocheck
                % No additional metadata for v2024.0 spires. Need to update!
                % 2024-04-18                                                       @todo
        % Mapping of NetCDF types to Matlab classes
        % I thought I could find it in the NetCDF API, but I don't see it
        matClass = containers.Map(...
                {'NC_DOUBLE', 'NC_FLOAT', 'NC_INT64', 'NC_UINT64', ...
                'NC_INT', 'NC_UINT', 'NC_SHORT', 'NC_USHORT', ...
                'NC_BYTE', 'NC_UBYTE', 'NC_CHAR', 'NC_STRING'}, ...
                {'double', 'single', 'int64', 'uint64', ...
                'int32', 'uint32', 'int16', 'uint16', ...
                'int8', 'uint8', 'char', 'string'});
        fillValues = struct(double = 9.9692099683868690e+36);
    end
    methods(Static)
        function varData = read(filePath, varName, startIdx, thisSize)
            % Read netcdf data by keeping types and not replacing nodata_values,
            % as ncread doesnt, since it automatically converts to double when
            % variable attribute FillValue is set in the netcdf file.
            %
            % Parameters
            % ----------
            % filePath: char. FilePath of the NetCdf file.
            % varName: char. Name of the variable within the file.
            % startIdx: array(int), as [dim1StartIdx, dim2StartIdx, dim3StartIdx], using
            %   matlab indices (starting with 1, not 0 as in c).
            % thisSize: array(int) as [dim1ThisSize, dim2ThisSize, dim3ThisSize].
            %   size along each dimension to return.
            %
            % NB: Can only read files with variables having three dimensions:
            % rowxcolumnxtime.                                                  @warning
            thisFunction = 'ESPNetCDF.read';
            ncid = netcdf.open(netCDFFilePath,'NC_NOWRITE');
            try
              varid = netcdf.inqVarID(ncid, varName);
              data = netcdf.getVar(ncid,varid, startIdx - 1, thisSize);
                % low level function, arrays start with index 0.
            catch e
              netcdf.close(ncid)
              error('ESPNetCDF_read', [thisFunction, ': Impossible to read %s.'], ...
                netCDFFilePath);
            end
        end
    end
    methods
        function obj = ESPNetCDF(region, thisDate)
            % ESPNetCDF constructor, initializes global/projection metadata
            %
            % Parameters
            % ----------
            % region: Region obj. Should be tile region.
            %
            % Return
            % ------
            % obj:  ESPNetCDF Obj.
            obj.region = region;
            obj.thisDate = thisDate;
            % obj = obj.setGlobalAttributes();
        end
        function obj = addGlobalAttributes(obj, attribute)
            % Adds global attributes to currently open nc file
            %
            % attribute: struct with string attributes to set

            varid = netcdf.getConstant('GLOBAL');

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                    fNames{i}, attribute.(fNames{i}));
            end
        end
        function closeFile(obj)
            % Set the crs and date information and close the NetCDF file.

            % 1. Initialize.
            if ~obj.ncid
                fprintf('%s: no open file id to write\n', mfilename());
                return;
            end
            modisData = obj.region.espEnv.modisData;
            % Populate the coordinate reference system (crs)
            % information
            % Verify MODIS sinusoidal
            if ~ismember('modisSinusoidal', ...
                fieldnames(modisData.projection))
                ME = MException('ESPNetCDF:inputError', ...
                    '%s: unexpected modisData', ...
                mfilename());
                throw(ME)
            end

            % 2. Populate the GeoTransform.
            % A geotransform consists in a set of 6 coefficients:
            %
            % GT(0) x-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(1) w-e pixel resolution / pixel width.
            % GT(2) row rotation (typically zero).
            % GT(3) y-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(4) column rotation (typically zero).
            % GT(5) n-s pixel resolution / pixel height
            %       (negative value for a north-up image).
            %
            % See details:
            % https://gdal.org/tutorials/geotransforms_tut.html
            % After an e-mail exchange with Scott 2023-09-07, it appears that the
            % Geotransform is a string separated by spaces and ended by a space.

            myRR = obj.region.getMapCellsReference();
            GeoTransform = sprintf('%.20f %.20f 0.0 %.20f 0.0 %.20f ', ...
              myRR.XWorldLimits(1), myRR.CellExtentInWorldX, myRR.YWorldLimits(2), ...
              -1 * myRR.CellExtentInWorldY);
              % don't use num2str here, since it rounds to 4 decimals, which might
              % create a problem when cutting in comparison with other modis type tiles
              % as mod10 2024-05-08 chat with Ross.
%{
            [...
                num2str(myRR.XWorldLimits(1)), ' ', ...
                num2str(myRR.CellExtentInWorldX), ' ', '0.0', ' ', ...
                num2str(myRR.YWorldLimits(2)), ' ', '0.0', ' ', ...
                num2str(-1 * myRR.CellExtentInWorldY), ' '];
%}
            params = myRR.ProjectedCRS.ProjectionParameters;

            % 3.Define the crs variable. It is instantiated first with name 'sinusoidal'
            % to be referable in the corresponding attributes of each variable,
            % and then crs. I parametered the 'sinusoidal' with what works for QGIS 3.28
            % and let the crs as parametered as Mary Jo did. Note that before 2023-08-31
            % only crs was parametered and there was no sinusoidal var.
            % Not sure if both 'crs' and 'sinusoidal' variables are
            % necessary but it's better to let them as such for now.            @tocheck
            %
            % Projection CF netcdf doc:
            % http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#_sinusoidal
            %
            % It will be no data, just attributes
            % Indicate that there is no dimid with []
            % No need to call putVar since there's no data here
            % Attributes will be written in closeFile

            % 3.1. Sinusoidal.
            % Patch for matlab 2021. For matlab 2022 can use
            % myRR.ProjectedCRS.GeographicCRS.Spheroid.Radius
            % rather than
            % modisData.projection.modisSinusoidal.geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey   @todo
            attribute = struct(...
                grid_mapping_name = 'sinusoidal', ... %'crs', ... %'sinusoidal', ...
                false_easting = params.FalseEasting, ...
                false_northing = params.FalseNorthing, ...
                longitude_of_projection_origin = params.LongitudeOfNaturalOrigin, ...
                longitude_of_central_meridian = 0, ...
                long_name = 'Sinusoidal projection definition', ...
                longitude_of_prime_meridian = 0, ...
                semi_major_axis = modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
                inverse_flattening = 0, ...
                proj4 = modisData.projection.modisSinusoidal.proj4, ...
                spatial_ref = modisData.projection.modisSinusoidal.wkt2, ...
                crs_wkt = modisData.projection.modisSinusoidal.wkt2, ...
                GeoTransform = GeoTransform);

            varid = netcdf.defVar(obj.ncid, 'crs', 'NC_CHAR', []); %'sinusoidal', 'NC_CHAR', []);
            netcdf.defVarFill(obj.ncid, varid, true, '');
            netcdf.endDef(obj.ncid);

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                   fNames{i}, attribute.(fNames{i}));
            end

%{
            % 3.2. Crs.
            attribute = struct( ...
                'grid_mapping_name', 'sinusoidal', ...
                'longitude_of_projection_origin', ...
                params.LongitudeOfNaturalOrigin, ...
                'earth_radius', ...
                modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
                'false_easting', params.FalseEasting, ...
                'false_northing', params.FalseNorthing, ...
                'GeoTransform', GeoTransform, ...
                'proj4', modisData.projection.modisSinusoidal.proj4, ...
                'wkt', modisData.projection.modisSinusoidal.wkt ...
                );
            attribute = struct(...
            'grid_mapping_name', 'sinusoidal', ...
            'longitude_of_projection_origin', ...
            params.LongitudeOfNaturalOrigin, ...
            'earth_radius', ...
            modisData.projection.modisSinusoidal. ...
                    geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey, ...
            'false_easting', params.FalseEasting, ...
            'false_northing', params.FalseNorthing, ...
            'GeoTransform', [...
                myRR.XWorldLimits(1), myRR.CellExtentInWorldX, ...
                0.0, ...
                myRR.YWorldLimits(2), 0.0, ...
                -1 * myRR.CellExtentInWorldY], ...
            'proj4', '+proj=sinu +lon_0=0 +x_0=0 +y_0=0 +a=6371007.181 +b=6371007.181 +units=m +no_defs +nadgrids=@null +wktext', ...
            'wkt', "PROJCRS[""MODIS Sinusoidal"",BASEGEOGCRS[""User"",DATUM[""World Geodetic Survey 1984"",SPHEROID[""Authalic_Spheroid"",6371007.181,0.0]],PRIMEM[""Greenwich"",0.0],UNIT[""Degree"",0.0174532925199433]],PROJECTION[""Sinusoidal""],PARAMETER[""False_Easting"",0.0],PARAMETER[""False_Northing"",0.0],PARAMETER[""Central_Meridian"",0.0],UNIT[""Meter"",1.0]]" ...
            );
            varid = netcdf.defVar(obj.ncid, 'crs', 'NC_INT', []);
            netcdf.endDef(obj.ncid);

            fNames = fieldnames(attribute);
            for i = 1:length(fNames)
                netcdf.putAtt(obj.ncid, varid, ...
                    fNames{i}, attribute.(fNames{i}));
            end
%}

            % 4. Other date metadata and close file.
            % ACDD: ISO 8601:2004: YYYY-MM-DDThh:mm:ss<zone>
            nowStr = datetime('now', 'TimeZone', 'UTC', 'Format', ...
                'yyyy-MM-dd HH:mm:SSxxxxx');
            nowStr = strrep(char(nowStr), ' ', 'T');
            varid = netcdf.getConstant('GLOBAL');
            netcdf.putAtt(obj.ncid, varid, 'date_created', nowStr);
            netcdf.putAtt(obj.ncid, varid, 'date_modified', nowStr);

            netcdf.close(obj.ncid);
            fprintf('%s: wrote %s\n', mfilename(), obj.netCDFFilePath);
        end
        function obj = createFile(obj, netCDFFilePath)
            % Updates the current object by adding id and properties and
            % creating the physical file netCDFFilePath with globalAttribute attributes.
            %
            % Parameters
            % ----------
            % netCDFFilePath: char. Filepath of the netcdf file which will contain the
            %   data.
            %
            % Return
            % obj: ESPNetCDF obj. The updated ESPNetCDF object.
            %
            % C API syntax to Matlab netcdf low-level:
            % https://www.mathworks.com/help/matlab/import_export/
    	    % map-netcdf-api-syntax-to-matlab-syntax.html
            %
            % NetCDF best practices:
            % https://docs.unidata.ucar.edu/nug/current/best_practices.html
            %
            % great resource, includes DIWG recommendations:
            % https://unidata.github.io/python-training/workshop/CF%20Conventions/netcdf-and-cf-the-basics/#gridded

            try
        	    % CLOBBER allows overwrite
        	    % NetCDF4 is for 4 instead of 3
        	    cmode = bitor(netcdf.getConstant('CLOBBER'), ...
                    netcdf.getConstant('NETCDF4'));

        	    % make a template file with unchanging global metadata
                if isfile(netCDFFilePath)
                    delete(netCDFFilePath); % We need to delete the file before creating it.
                end
        	    obj.ncid = netcdf.create(netCDFFilePath, cmode);
                obj.addGlobalAttributes(obj.globalAttribute);

            catch e
                if obj.ncid
                    netcdf.close(obj.ncid);
                end
                rethrow(e);
            end

            % Save the filename for additional operations
            obj.netCDFFilePath = netCDFFilePath;
        end
        function obj = setCoordinateVars(obj)
            % Defines coordinate variables for the region (tile only).

            % 1. Get the reference and projection/geographic properties attached to the
            % region.
            modisData = obj.region.espEnv.modisData;
            myRR = obj.region.getMapCellsReference();
            nrows = myRR.RasterSize(1);
            ncols = myRR.RasterSize(2);

            % 2. Calculate center of UL cell.
            ULx_m = myRR.XWorldLimits(1) + (myRR.CellExtentInWorldX / 2.);
            ULy_m = myRR.YWorldLimits(2) - (myRR.CellExtentInWorldY / 2.);

            % 3. Calculate the overall x and y projected range.
            ntilecols = modisData.sensorProperties.tiling.columnCount;
            ntilerows = modisData.sensorProperties.tiling.rowCount;
            x_extent_m = ntilecols * ncols * myRR.CellExtentInWorldX;
            y_extent_m = ntilerows * nrows * myRR.CellExtentInWorldY;
            x_valid_range = [ -1 * x_extent_m / 2, x_extent_m / 2 ];
            y_valid_range = [ -1 * y_extent_m / 2, y_extent_m / 2 ];

            % 4. Define the dimension variables: time, x, y.
            time_dimID = netcdf.defDim(obj.ncid, 'time', ...
                netcdf.getConstant('NC_UNLIMITED'));
            x_dimID = netcdf.defDim(obj.ncid, 'x', ncols);
            y_dimID = netcdf.defDim(obj.ncid, 'y', nrows);

            % 5. Define the time attributes.
            time_varID = netcdf.defVar(obj.ncid, 'time', 'NC_DOUBLE', ...
                time_dimID);
            netcdf.defVarFill(obj.ncid, time_varID, true, obj.fillValues.double);
            netcdf.putAtt(obj.ncid, time_varID, 'standard_name', 'time');
            netcdf.putAtt(obj.ncid, time_varID, 'calendar', 'standard');
            netcdf.putAtt(obj.ncid, time_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, time_varID, 'long_name', 'ANSI date');
            netcdf.putAtt(obj.ncid, time_varID, 'units', ...
                sprintf('days since %s', ...
                datestr(obj.epochDt, 'yyyy-mm-dd HH:MM:SS')));
            netcdf.putAtt(obj.ncid, time_varID, 'axis', 'T');
            netcdf.putAtt(obj.ncid, time_varID, 'valid_range', ...
                [0., realmax]);

            % 6. Define the x and y attributes.
            x_varID = netcdf.defVar(obj.ncid, 'x', 'NC_DOUBLE', x_dimID);
            netcdf.defVarFill(obj.ncid, x_varID, true, obj.fillValues.double);
            netcdf.putAtt(obj.ncid, x_varID, 'standard_name', ...
                'projection_x_coordinate');
            netcdf.putAtt(obj.ncid, x_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, x_varID, 'long_name', 'x');
            netcdf.putAtt(obj.ncid, x_varID, 'units', 'meters');
            netcdf.putAtt(obj.ncid, x_varID, 'axis', 'X');
            netcdf.putAtt(obj.ncid, x_varID, 'valid_range', x_valid_range);

            y_varID = netcdf.defVar(obj.ncid, 'y', 'NC_DOUBLE', y_dimID);
            netcdf.defVarFill(obj.ncid, y_varID, true, obj.fillValues.double);
            netcdf.putAtt(obj.ncid, y_varID, 'standard_name', ...
                'projection_y_coordinate');
            netcdf.putAtt(obj.ncid, y_varID, 'coverage_content_type', ...
                'coordinate');
            netcdf.putAtt(obj.ncid, y_varID, 'long_name', 'y');
            netcdf.putAtt(obj.ncid, y_varID, 'units', 'meters');
            netcdf.putAtt(obj.ncid, y_varID, 'axis', 'Y');
            netcdf.putAtt(obj.ncid, y_varID, 'valid_range', y_valid_range);

            % 7. End define mode before populating variable data
            netcdf.endDef(obj.ncid);

            % 8. Populate x and y (time will be populated with actual data)
            netcdf.putVar(obj.ncid, x_varID, ...
                ULx_m + (myRR.CellExtentInWorldX * (0:(ncols - 1))));
            netcdf.putVar(obj.ncid, y_varID, ...
                ULy_m - (myRR.CellExtentInWorldY * (0:(nrows - 1))));
        end
        function obj = setDate(obj, thisDate)
            % Defines the date for data in the file. NB: there's only one date per file.
            %
            % Parameters
            % ----------
            % thisDate : datetime.

            % Convert thisDate to days since epoch.
            seconds_per_day = 24 * 60 * 60;
            time_varID = netcdf.inqVarID(obj.ncid, 'time');
            netcdf.putVar(obj.ncid, time_varID, 0, ...
                double(convertTo(thisDate, 'epochtime', ...
                'Epoch', string(obj.epochDt))) / seconds_per_day );

        end
        function obj = setGlobalAttributes(obj)
            % Defines object static and runtime global attributes

            % Set static global attributes
            obj.globalAttribute = obj.defaultGlobalAttribute;
            % NB: dirty way of changing attributes, should be all in a conf file   @todo
            if strcmp(obj.region.espEnv.modisData.versionOf.VariablesNetCDF, ...
                'v2022.0')
                theseFieldNames = fieldnames(obj.v2022_0Attribute);
                for fieldIdx = 1:length(theseFieldNames)
                    thisFieldName = theseFieldNames{fieldIdx};
                    obj.globalAttribute.(thisFieldName) = ...
                        obj.v2022_0Attribute.(thisFieldName);
                end
            elseif ismember(obj.region.espEnv.modisData.versionOf.VariablesNetCDF, ...
                {'v2024.0', 'v2024.0d', 'v2024.0f', 'v2025.nrt'}) % TEMPORARY v2025 20241209.
                theseFieldNames = fieldnames(obj.v2024_0Attribute);
                for fieldIdx = 1:length(theseFieldNames)
                    thisFieldName = theseFieldNames{fieldIdx};
                    obj.globalAttribute.(thisFieldName) = ...
                        obj.v2024_0Attribute.(thisFieldName);
                end
            end
            
             obj.globalAttribute.product_version = ...
                obj.region.espEnv.modisData.versionOf.VariablesNetCDF;
            if strcmp(obj.region.espEnv.modisData.versionOf.VariablesNetCDF, 'v2022.0')
                obj.globalAttribute.product_version = 'v1.0';
                % DAAC requirement for HMA released in 2024.
            end
            obj.globalAttribute.citation = replace(obj.globalAttribute.citation, ...
                '{product_version}', obj.globalAttribute.product_version);
            [~, currentGitHash] = system('git rev-parse --short HEAD');
            obj.globalAttribute.software_version_id = ...
                erase(currentGitHash, newline);    

            % Add runtime global attributes
            if strcmp(obj.region.espEnv.modisData.versionOf.VariablesNetCDF, 'v2024.0d')
              obj.globalAttribute.product_version = 'v2024.hist';
              obj.globalAttribute.title = 'MODIS/Terra L3 Daily 500m SIN Grid SPIReS Snow Cover and Snow Surface Properties, Version v2024.hist.';
              obj.globalAttribute.summary = 'This dataset contains daily raster images of snow cover and snow surface properties. Snow cover, grain size and dust concentration were unmixed from the daily reflectance of the MOD09GA Terra Collection 6 v061 (Vermote and Wolfe, 2021) using an adapted version of the SPIReS algorithm (Bair et al., 2021), that we named SPIReS v2024.hist, with a removal of clouds and data errors. The data were then temporally interpolated to fill the cloudy days, and the snow cover duration was calculated from the start of the water year (October 1st for the northern hemisphere, April 1st for the southern one). Deltavis, radiative forcing, and albedos were calculated using an adaptation of the ParBal algorithm (Bair et al., 2018), that we included in SPIReS v2024.hist.';

              obj.globalAttribute.references = ['Bair, E.H., T. Stillinger, and J. Dozier. 2021. ', ...
            'Snow Property Inversion from Remote Sensing (SPIReS): ', ...
            'A generalized multispectral unmixing approach with examples ', ...
            'from MODIS and Landsat 8 OLI. IEEE Transactions on Geoscience ', ...
            'and Remote Sensing 59.9: 7270-7284, doi: 10.1109/TGRS.2020.3040328. https://github.com/edwardbair/SPIRES. ', ...
            'Stillinger, T., K. Rittger, M.S. Raleigh, A. Michell, R.E. Davis, ', ...
            'and E.H. Bair. 2023. Landsat, MODIS, and VIIRS snow cover mapping ', ...
            'algorithm performance as validated by airborne lidar datasets. ', ...
            'The Cryosphere 17: 567-590, doi: 10.5194/tc-17-567-2023. ',...
            'Bair, E. H., A. Abreu Calfa, K. Rittger, and J. Dozier. 2018. Using machine learning for real-time estimates of snow water equivalent in the watersheds of Afghanistan. The Cryosphere 12.5: 1579-1594, doi: 10.5194/tc-12-1579-2018. https://github.com/edwardbair/ParBal. Bair, E. H., K. Rittger, R. E. Davis, T. H. Painter, and Dozier, J. 2016. Validating reconstruction of snow water equivalent in California''s Sierra Nevada using measurements from the NASA Airborne Snow Observatory. Water Resources Research 52, doi: 10.1002/2016WR018704. Rittger, K., Bair, E.H., Kahl, A., and Dozier, J. 2016. Spatial estimates of snow water equivalent from reconstruction. Advances in Water Resources 94: 345-363, doi: 10.1016/j.advwatres.2016.05.015. Vermote, E., and R. Wolfe. 2021. MODIS/Terra Surface Reflectance Daily L2G Global 1km and 500m SIN Grid V061. Distributed by NASA EOSDIS Land Processes Distributed Active Archive Center, doi: 10.5067/MODIS/MOD09GA.061.MODIS.'];
            % Top for spires, mid for Parbal, bottom for mod09ga.
            
              obj.globalAttribute.acknowledgement = ['These data are produced and supported by the Institute of Arctic and Alpine Research. The data products were produced with funding from NASA grants 80NSSC22K0703 (Rittger, TAS), 80NSSC20K1721 (Rittger, HMA), 80NSSC22K0929 (Rittger, WR), 80NSSC23K1456 (Rittger, Alps), 80NSSC24K1270 (Rittger, IDS). This work utilized the Alpine high performance computing resource at the University of Colorado Boulder. Alpine is jointly funded by the University of Colorado Boulder, the University of Colorado Anschutz, and Colorado State University. Data storage supported by the University of Colorado Boulder PetaLibrary.'];
              
              obj.globalAttribute.citation = ['Rittger, K., S. J. P. Lenard, ', ...
                ' Ross T. Palomaki, E. H. Bair, and J. Dozier. 2024. ', ...
                'MODIS/Terra L3 Daily 500m SIN Grid SPIReS Snow Cover and Snow Surface Properties, Version v2024.hist. ', ...
                'INSTAAR, University of Colorado, Boulder, CO, USA. ', ...
                ' Digital Media. ', ...
                'https://github.com/sebastien-lenard/snow-today. ', ...
                'ftp://dtn.rc.colorado.edu/shares/snow-today.'];
                
              obj.globalAttribute.comment = ['Snow cover validated with 3 m airborne snow maps on ', ...
              '116 days (Stillinger et al., 2023); Snow albedo validated using ', ...
              'terrain correct in-situ observations at 3 sites for ~20 years', ...
              ' with spatial comparisons to 31 ASO Inc hyperspectral airborne ', ...
              'flights (Palomaki et al., RSE, in review). Preliminary radiative', ...
              ' forcing evaluation performed at 1 site in the San Juan mountains', ...
              ' of Colorado.'];
            end
           

            % Box longitude/latitude coordinates for earthData Viewer.
            regionConf = obj.region.myConf.region;
            obj.globalAttribute.geospatial_bounds_crs = 'EPSG:4326';
            obj.globalAttribute.geospatial_bounds = ['POLYGON((', ...
                sprintf('%.8f', regionConf.boxLatitude1), ' ', ...
                sprintf('%.8f', regionConf.boxLongitude1), ', ', ...
                sprintf('%.8f', regionConf.boxLatitude2), ' ', ...
                sprintf('%.8f', regionConf.boxLongitude2), ', ', ...
                sprintf('%.8f', regionConf.boxLatitude3), ' ', ...
                sprintf('%.8f', regionConf.boxLongitude3), ', ', ...
                sprintf('%.8f', regionConf.boxLatitude4), ' ', ...
                sprintf('%.8f', regionConf.boxLongitude4), ', ', ...
                sprintf('%.8f', regionConf.boxLatitude1), ' ', ...
                sprintf('%.8f', regionConf.boxLongitude1), '))'];
        end
        function obj = setVariable(obj, var, ...
                varName, varType, attribute)
            % Sets a new variable in the file
            % var : data to populate
            % varName : name of variable to populate
            % varType : variable type
            % attribute : 2xN cell array with 'attribute', value for each
            %     of N attributes
            % Note that valid_range, valid_min, valid_max and
            % _FillValue data values must be same type as var

            time_dimID = netcdf.inqDimID(obj.ncid, 'time');
            x_dimID = netcdf.inqDimID(obj.ncid, 'x');
            y_dimID = netcdf.inqDimID(obj.ncid, 'y');

            %varID = netcdf.defVar(obj.ncid, varName, ...
            %    varType, [time_dimID y_dimID x_dimID]);
            varID = netcdf.defVar(obj.ncid, varName, ...
                varType, [x_dimID y_dimID time_dimID]);
            theseFieldnames = fieldnames(attribute);
            for i = 1:length(theseFieldnames)
                thisFieldName = theseFieldnames{i};
                if ismember(thisFieldName, {'valid_range'})
                    netcdf.putAtt(obj.ncid, varID, ...
                       thisFieldName, attribute.(theseFieldnames{i}), varType);
                elseif strcmp(thisFieldName, 'FillValue')
                    % '_FillValue' in netcdf file.
                    % NB: cant use putAtt() for FillValue, 2024-01-09.
                    % NB: default behavior of ncread() when FillValue set to true
                    % is to load the data as double (even if they are stored as uint8).
                    netcdf.defVarFill(obj.ncid, varID, false, ...
                        attribute.(thisFieldName));
                else
                    netcdf.putAtt(obj.ncid, varID, ...
                       thisFieldName, attribute.(thisFieldName));
                end
            end

            % Turn on compression
            doShuffle = true;
            doDeflate = true;
            deflateLevel = 1;
            netcdf.defVarDeflate(obj.ncid, varID, ...
                doShuffle, doDeflate, deflateLevel);

            % End define mode before populating variable data
            netcdf.endDef(obj.ncid);

            netcdf.putVar(obj.ncid, varID, ...
                reshape(var', 1, size(var,2), size(var,1)));
        end
    end
    methods(Static)
%{
        function mosaicToNetCDF(matFilePath, bigRegionName, tileRegion, ...
                netCDFFilePath)
            % NB: developed but not sure it will be used.                    @deprecated
            % Make an STC tileID .nc file from the input mosaic matFilePath
            tileID = tileRegion.regionName;
            espEnv = tileRegion.espEnv;

            % TBD: parse inputs
            fprintf('%s: Mosaic file: %s\n', mfilename(), matFilePath);
            fprintf('%s: bigRegionName: %s\n', mfilename(), bigRegionName);
            fprintf('%s: tileID: %s\n', mfilename(), tileID);
            fprintf('%s: .nc file: %s\n', mfilename(), netCDFFilePath);

            % Create/populate the generic metadata for a v2023.1 file
            version = 'v2023.1';
            versionLabel = replace(version, '.', '_');

            % Create/populate the NetCDF file metadata
            thisNetCDF = ESPNetCDF(tileRegion, version = version);
            thisNetCDF = thisNetCDF.createFile(netCDFFilePath);
            thisNetCDF = thisNetCDF.setCoordinateVars();

            data = load(matFilePath, 'dateval');
            thisNetCDF = thisNetCDF.setDate(...
                datetime(data.dateval, 'ConvertFrom', 'datenum'));

            % Figure out the row/col subset for the requested tileID
            % in the input mosaic--I think Sebastien has a function for
            % this in the new main branch that we can use instead of
            % hardcoding here
            % I'm hardcoding this for now using bigRegionName and tileID
            if strcmp(bigRegionName,'westernUS')

                % westernUS
                s.h08v04 = {1,2400,1,2400};
                s.h08v05 = {2401,4800,1,2400};
                s.h09v04 = {1,2400,2401,4800};
                s.h09v05 = {2401,4800,2401,4800};
                s.h10v04 = {1,2400,4801,7200};

            elseif strcmp(bigRegionName, 'USAlaska')

        	    % Alaska
                s.h07v03 = {4801,7200,1,2400};
                s.h08v03 = {4801,7200,2401,4800};
                s.h09v02 = {2401,4800,4801,7200};
                s.h09v03 = {4801,7200,4801,7200};
                s.h10v02 = {2401,4800,7201,9600};
                s.h10v03 = {4801,7200,7201,9600};
                s.h11v02 = {2401,4800,9601,12000};
                s.h11v03 = {4801,7200,9601,12000};
                s.h12v01 = {1,2400,12001,14400};
                s.h12v02 = {2401,4800,12001,14400};
                s.h13v01 = {1,2400,14401,16800};
                s.h13v02 = {2401,4800,14401,16800};

            else

                ME = MException('ESPNetCDF:inputError', ...
                    '%s: invalid bigRegionName %s', ...
                    mfilename(), bigRegionName);
                throw(ME)

            end

            rowStart = s.(tileID){1};
            rowStop = s.(tileID){2};
            colStart = s.(tileID){3};
            colStop = s.(tileID){4};

            % Add variable data from the .mat file
            availableVariables = espEnv.myConf.variable(...
                find(espEnv.myConf.variable.(['write_netCDF_' versionLabel]) == 1), :);
            nVars = size(availableVariables, 1);
            for var = 1:nVars
                rec = availableVariables(var, :);
                data = load(matFilePath, rec.('output_name'){1}, ...
                    [rec.('output_name'){1} '_divisor']);

                % Subset the large variable mosaic array
                % to the tileID coords
                data.(rec.('output_name'){1}) = ...
                    data.(rec.('output_name'){1})( ...
                    rowStart:rowStop, colStart:colStop);

        	    % Make 2 x N cell array with attributes and values
                % Ensure _FillValue and valid_range are correct type
                attribute = {...
                    'long_name', rec.('netCDF_long_name'){1}; ...
                    'standard_name', rec.('netCDF_standard_name'){1}; ...
                    'units', rec.('netCDF_units'){1}; ...
                    '_FillValue', ...
                    cast(rec.('nodata_value'), ...
                    ESPNetCDF.matClass(rec.('netCDF_type'){1})); ...
                    'valid_range', ...
                    cast([rec.('min') rec.('max')], ...
                    ESPNetCDF.matClass(rec.('netCDF_type'){1})); ...
                    'description', rec.('netCDF_description'){1}};
        	    thisNetCDF = ...
                    thisNetCDF.setVariable(data.(rec.('output_name'){1}), ...
                    rec.('netCDF_varName'){1}, rec.('netCDF_type'){1}, ...
                    attribute);
            end

            % Add a few more global attributes from the .mat file
            % that we want to carry along into the .nc file
            data = load(matFilePath, 'mindays', 'zthresh', 'stcStruct', ...
                'files');
            for i=1:numel(data.zthresh)
                zthresh(i) = strjoin(string(data.zthresh{i}));
            end
            attribute = struct(...
            'mindays', strjoin(string(data.mindays), ', '),...
            'zthresh', strjoin(zthresh,', '));
            fNames = fieldnames(data.stcStruct);
            for i = 1:length(fNames)
                if 1 == numel(data.stcStruct.(fNames{i}))
                    attribute.(['STC_', fNames{i}]) = ...
                        string(data.stcStruct.(fNames{i}));
                else
                    attribute.(['STC_', fNames{i}]) = ...
                        strjoin(string(data.stcStruct.(fNames{i})), ', ');
                end
            end
            for i=1:size(data.files, 1)
                if strcmp(data.files{i, 1}, tileID)
                    attribute.STC_file = data.files{i, 2};
                end
            end
            thisNetCDF.addGlobalAttributes(attribute);

            % Write it out
            thisNetCDF.closeFile();

        end
%}
        function generateNetCDFFromRegionAndMatFile(region, thisDate, ...
          matFilePath, netCDFFilePath)
          % Get information from a .mat file for a region and write them
          % in a CF-compliant netCDF file (classic NetCDF-4) with the projection
          % MODIS Sinusoidal correctly set (a tricky part!).
          %
          % Parameters
          % ----------
          % region: Region obj. Only tile.
          % thisDate: datetime.
          % matFilePath: char. Filepath of the .mat 'VariablesMatlab' or .tif
          %   'spiresdailytifsinu' file (version > v2025.nrt) to be published in
          %   netcdf, for variable snow_fraction_s (for version > v2025).
          % netCDFFilePath: char. Filepath of the generated .nc netcdf file.
          %
          % NB: Tile only, no big region.

          % 0. Initialize and check that the inputFile exist and has data.
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          objectName = region.name;
          espEnv = region.espEnv;
          modisData = region.espEnv.modisData;
          complementaryLabel = '';
          
          logger = Logger('netcdf');
          fprintf('%s: Start generating .nc %s from %s.\n', mfilename(), ...
            netCDFFilePath, matFilePath);
          if ~isfile(matFilePath)
            warning('%s: Inexistent %s.\n', mfilename(), matFilePath);
            return;
          end
          % TEMPORARY 20241209
          if strcmp(matFilePath(end - 3:end), '.mat')
            fileObj = matfile(matFilePath);
            
            % Check if data before generating the netcdf.
            if ismember(espEnv.modisData.versionOf.VariablesNetCDF, {'v2024.0d', 'v2024.1.0'})
              varName = 'albedo_muZ_s';
              dateToSkip = 1;
              if ~isempty(who(fileObj, varName))
                data = fileObj.(varName);
                if min(unique(data)) ~= intmax('uint8')
                  dateToSkip = 0;
                end
              end
              if dateToSkip == 1
                warning(['Skip %s: %s. No variable albedo_muZ_s, or data only', ...
                  'nodata.\n'], char(thisDate, 'yyyyMMdd'), matFilePath);
                return;
              end
            end
          end

          % 1. Copy the template into a new netcdf file.
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          % Each version has its own template.
          if ismember(espEnv.modisData.versionOf.spiresdailytifsinu, ...
              {'v2024.0d', 'v2024.1.0', 'v2023.0.1', 'v2023.0e', 'v03', 'v2022.0'}) 
              % NB: temporary'v2024.0d' to be renamed by 'v2024.1.0'.
              % NB: v2023.0.1 = v2023.0e + v2023.0
              inputDataLabel = 'VariablesMatlab';
          else % 'v2025.0.1+'
              inputDataLabel = 'spiresdailytifsinu';
          end
          if ismember(espEnv.modisData.versionOf.daacnetcdfv20220, ...
              {'v03', 'v2022.0'}) 
              % NB: temporary'v2024.0d' to be renamed by 'v2024.1.0'.
              outputDataLabel = 'daacnetcdfv20220';
          elseif ismember(espEnv.modisData.versionOf.daacnetcdfv202301, ...
              {'v2023.0.1'}) 
              outputDataLabel = 'daacnetcdfv202301';
          elseif ismember(espEnv.modisData.versionOf.VariablesNetCDF, {'v2023.0e'})
              outputDataLabel = 'VariablesNetCDF';
          else
              % 'v2025.0.1 % 'v2025.0.1', 'v2024.0d', 'v2024.1.0',
              outputDataLabel = 'outputnetcdf';
          end
          if isfile(netCDFFilePath)
            delete(netCDFFilePath);
          end
          templateNetCdfFilePath = [getenv('thisEspProjectDir'), ...
              'template/outputnetcdf.', ...
              espEnv.modisData.versionOf.(outputDataLabel), ...
              '.', espEnv.waterYearDate.getNrtOrHist(), '.nc'];
          [status, message] = copyfile(templateNetCdfFilePath, ...
              netCDFFilePath);
          if status ~= 1
            error('NetCDF:badcopy', ...
              ['ESPNetCDF.generateNetCDFFromRegionAndMatFile(): unable to ', ...
              'copy template %s to %s, %s.\n'], ...
              templateNetCdfFilePath, netCDFFilePath, message)
          end
          
          try
            ncFileId = netcdf.open(netCDFFilePath, 'WRITE');
            
            % 2. Global, geospatial, time attributes/data.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % 2.1. GeoTransform  (Tile only, no big region).
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % A geotransform consists in a set of 6 coefficients:
            %
            % GT(0) x-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(1) w-e pixel resolution / pixel width.
            % GT(2) row rotation (typically zero).
            % GT(3) y-coordinate of the upper-left corner
            %       of the upper-left pixel.
            % GT(4) column rotation (typically zero).
            % GT(5) n-s pixel resolution / pixel height
            %       (negative value for a north-up image).
            %
            % See details:
            % https://gdal.org/tutorials/geotransforms_tut.html
            % After an e-mail exchange with Scott 2023-09-07, it appears that the
            % Geotransform is a string separated by spaces and ended by a space.

            myRR = region.getMapCellsReference();
            GeoTransform = sprintf('%.20f %.20f 0.0 %.20f 0.0 %.20f ', ...
              myRR.XWorldLimits(1), myRR.CellExtentInWorldX, myRR.YWorldLimits(2), ...
              -1 * myRR.CellExtentInWorldY);
              % don't use num2str here, since it rounds to 4 decimals, which might
              % create a problem when cutting in comparison with other modis type tiles
              % as mod10 2024-05-08 chat with Ross.
            
            % Define the crs variable. It is instantiated first with name 'sinusoidal'
            % to be referable in the corresponding attributes of each variable,
            % and then crs. I parametered the 'sinusoidal' with what works for QGIS 3.28
            % and let the crs as parametered as Mary Jo did. Note that before 2023-08-31
            % only crs was parametered and there was no sinusoidal var.
            % Not sure if both 'crs' and 'sinusoidal' variables are
            % necessary but it's better to let them as such for now.            @tocheck
            %
            % Projection CF netcdf doc:
            % http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#_sinusoidal
            %
            % It will be no data, just attributes
            % Indicate that there is no dimid with []
            % No need to call putVar since there's no data here
            % Attributes will be written in closeFile

            % Sinusoidal.
            % Patch for matlab 2021. For matlab 2022 can use
            % myRR.ProjectedCRS.GeographicCRS.Spheroid.Radius
            % rather than
            % modisData.projection.modisSinusoidal.geoKeyDirectoryTag.GeogSemiMajorAxisGeoKey   @todo
            ncVarId = netcdf.inqVarID(ncFileId, 'crs');
            netcdf.putAtt(ncFileId, ncVarId, 'GeoTransform', GeoTransform);
            
            % 2.2. x and y dimension variables (Tile only, no big region).
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Get the reference and projection/geographic properties attached to the
            % region.
            nrows = myRR.RasterSize(1);
            ncols = myRR.RasterSize(2);

            % Calculate center of UL cell.
            ULx_m = myRR.XWorldLimits(1) + (myRR.CellExtentInWorldX / 2.);
            ULy_m = myRR.YWorldLimits(2) - (myRR.CellExtentInWorldY / 2.);

            % Calculate the overall x and y projected range.
            ntilecols = modisData.sensorProperties.tiling.columnCount;
            ntilerows = modisData.sensorProperties.tiling.rowCount;
            x_extent_m = ntilecols * ncols * myRR.CellExtentInWorldX;
            y_extent_m = ntilerows * nrows * myRR.CellExtentInWorldY;
            x_valid_range = [ -1 * x_extent_m / 2, x_extent_m / 2 ];
            y_valid_range = [ -1 * y_extent_m / 2, y_extent_m / 2 ];
            
            % Define the x and y attributes.
            ncVarId = netcdf.inqVarID(ncFileId, 'x');
            netcdf.putAtt(ncFileId, ncVarId, 'valid_range', x_valid_range);
            netcdf.putVar(ncFileId, ncVarId, ...
              ULx_m + (myRR.CellExtentInWorldX * (0:(ncols - 1))));

            ncVarId = netcdf.inqVarID(ncFileId, 'y');
            netcdf.putAtt(ncFileId, ncVarId, 'valid_range', y_valid_range);
            netcdf.putVar(ncFileId, ncVarId, ...
                ULy_m - (myRR.CellExtentInWorldY * (0:(nrows - 1))));

            % 2.3. Date of the dataset.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Convert thisDate to days since epoch.
            ncVarId = netcdf.inqVarID(ncFileId, 'time');
            netcdf.putAtt(ncFileId, ncVarId, 'valid_range', ...
              [0., realmax]);
            seconds_per_day = 24 * 60 * 60;
            ncVarId = netcdf.inqVarID(ncFileId, 'time');
            netcdf.putVar(ncFileId, ncVarId, 0, ...
              double(convertTo(thisDate, 'epochtime', ...
              'Epoch', string(ESPNetCDF.epochDt))) / seconds_per_day );
            
            ncVarId = netcdf.getConstant('GLOBAL');
            netcdf.putAtt(ncFileId, ncVarId, 'time_coverage_start', string( ...
              datetime(year(thisDate), month(thisDate), day(thisDate), ...
              0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ'));
            netcdf.putAtt(ncFileId, ncVarId, 'time_coverage_end', string( ...
              datetime(year(thisDate), month(thisDate), day(thisDate) + 1, ...
              0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ'));
                
            % 2.4. Box longitude/latitude coordinates for earthData Viewer.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            regionConf = region.myConf.region;
            geospatialBounds = ['POLYGON((', ...
              sprintf('%.8f', regionConf.boxLatitude1), ' ', ...
              sprintf('%.8f', regionConf.boxLongitude1), ', ', ...
              sprintf('%.8f', regionConf.boxLatitude2), ' ', ...
              sprintf('%.8f', regionConf.boxLongitude2), ', ', ...
              sprintf('%.8f', regionConf.boxLatitude3), ' ', ...
              sprintf('%.8f', regionConf.boxLongitude3), ', ', ...
              sprintf('%.8f', regionConf.boxLatitude4), ' ', ...
              sprintf('%.8f', regionConf.boxLongitude4), ', ', ...
              sprintf('%.8f', regionConf.boxLatitude1), ' ', ...
              sprintf('%.8f', regionConf.boxLongitude1), '))'];
            
            netcdf.putAtt(ncFileId, ncVarId, 'geospatial_bounds', geospatialBounds);

            % 2.5. Creation date.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            nowStr = datetime('now', 'TimeZone', 'UTC', 'Format', ...
              'yyyy-MM-dd HH:mm:SSxxxxx');
            nowStr = strrep(char(nowStr), ' ', 'T');
            netcdf.putAtt(ncFileId, ncVarId, 'date_created', nowStr);
            netcdf.putAtt(ncFileId, ncVarId, 'date_modified', nowStr);
            
            % 2.6. Other global attributes for some versions.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            if ismember(region.espEnv.modisData.versionOf.VariablesNetCDF, ...
              {'v03', 'v2022.0', 'v2023.0d'}) % obsolete, 'v2022.0', 'v2023.0', 'v2023.1', 'v2023.0a', 'v2023.0d'}) % TODO 20241211: check whether v2023.hist is v2023.0d or v2023.0e.
              data = load(matFilePath, 'files').files;
              [~, stcFileName, stcFileExt] = fileparts(data{1,2});
              netcdf.putAtt(ncFileId, ncVarId, 'STC_file', ...
                sprintf('%s%s', stcFileName, stcFileExt));
            end
            
            % 3. variable snow data.
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            writeNetCDFField = 'v2024_0';
              % NB: all this should be translated using configuration of
              % versionvariables rather than of variables.                     @todo
            if ismember(region.espEnv.modisData.versionOf.VariablesNetCDF, ...
              {'v2023.0d', 'v2023.0e', 'v2023.1', 'v2023.0.1'})
                writeNetCDFField = 'v2023_1';
            elseif ismember(region.espEnv.modisData.versionOf.VariablesNetCDF, {'v03', 'v2022.0'})
                writeNetCDFField = 'v2022_0';
            end % Specific case for HMA ASHimalayas v2022.0. Otherwise we suppose
                % all available fields are same as v2023.1
            writeNetCDFField = ['write_netCDF_', writeNetCDFField];
            availableVariables = region.espEnv.myConf.variable(...
                find(region.espEnv.myConf.variable.(writeNetCDFField) == 1), :);
            for varIdx = 1:size(availableVariables, 1)
              varConf = availableVariables(varIdx, :);
              varName = varConf.('output_name'){1};
%{ 
            % OBSOLETE?
              if strcmp(varName, 'calculated_from_rare_observation')
                data = zeros([2400, 2400], 'uint8');
                ncVarId = netcdf.inqVarID(ncFileId, 'calculated_from_rare_observation');
                netcdf.putVar(ncFileId, ncVarId, ...
                  reshape(data', 1, size(data, 2), size(data, 1)));
                continue;
              end
%}
              outputVarName = varConf.('netCDF_varName'){1};
              % TEMPORARY 20241209.
              if ~strcmp(espEnv.modisData.versionOf.spiresdailytifsinu, 'v2025.0.1')
                if isempty(who(fileObj, varName))
                  warning('Skip absent variable %s in %s.\n', varName, ...
                    matFilePath);
                  continue;
                end
              end
              % Dirty tweak for v2025.nrt 20241209.
              divisor = 1;
              if ismember(espEnv.modisData.versionOf.(outputDataLabel), ...
                {'v2025.0.1', 'v2024.1.0'})
                complementaryLabel = '';
                data = struct();
                force = struct(outputDataLabel = outputDataLabel); 
                  % this force allows division for dust_concentration.
                data.(varName) = espEnv.getDataForDateAndVarName(objectName, ...
                    inputDataLabel, thisDate, varName, complementaryLabel, ...
                    force = force);
              else
                data = load(matFilePath, varName, ...
                    [varName '_divisor']);
                divisor = data.([varName, '_divisor']);
              end
              
              % Handle divisor that is not trivial (and adjust type)
              % This is special case for v2022.0 albedo variable
              if divisor ~= 1 && strcmp(writeNetCDFField, 'write_netCDF_v2022_0')
                data = ...
                  cast(...
                  data.(varName) / double(divisor), ...
                  ESPNetCDF.matClass(varConf.('netCDF_type'){1}));
              else
                data = data.(varName);
              end
              
              if strcmp(class(data), 'logical')
                  data = uint8(data);
              end
              % for v2023.0.1 calculated_from_rare_observation.
              
              % NBL
              %grid_mapping = 'crs'); %'sinusoidal'); % this grid_mapping references the
                  % general grid_mapping and wasn't present in the first versions
                  % of this script (before 2023-08-31).
              % Before 20241126: description = varConf.('netCDF_description'){1}, ...
              % Change asked by Kara.
              
              % scale_factor = varConf.('netCDF_scale_factor')(1), ...: We don't want
              % this, since by default convert the data into float.

              ncVarId = netcdf.inqVarID(ncFileId, outputVarName);

              netcdf.putVar(ncFileId, ncVarId, ...
                reshape(data', 1, size(data, 2), size(data, 1)));
            end % for varIdx.
            
          % 4. Close file.
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          catch e
            if ncFileId
                netcdf.close(ncFileId);
            end
            rethrow(e);
          end
          
          netcdf.close(ncFileId);
          fprintf('%s: wrote %s\n', mfilename(), netCDFFilePath);
%{
          % obsolete. 20241211.

          % 2. Add variables, their values and attributes.
          writeNetCDFField = 'v2024_0';
            % NB: all this should be translated using configuration of
            % versionvariables rather than of variables.                     @todo
          if ismember(region.espEnv.modisData.versionOf.VariablesNetCDF, ...
            {'v2023.0e', 'v2023.1'})
              writeNetCDFField = 'v2023_1';
          elseif strcmp(region.espEnv.modisData.versionOf.VariablesNetCDF, 'v2022.0')
              writeNetCDFField = 'v2022_0';
          end % Specific case for HMA ASHimalayas v2022.0. Otherwise we suppose
              % all available fields are same as v2023.1
          writeNetCDFField = ['write_netCDF_', writeNetCDFField];
          availableVariables = region.espEnv.myConf.variable(...
              find(region.espEnv.myConf.variable.(writeNetCDFField) == 1), :);
          
          % Create/populate the NetCDF file metadata
          thisNetCDF = ESPNetCDF(region, thisDate);
          thisNetCDF = thisNetCDF.createFile(netCDFFilePath);
          try
              thisNetCDF = thisNetCDF.setCoordinateVars();
              thisNetCDF = thisNetCDF.setDate(thisDate);

              for varIdx = 1:size(availableVariables, 1)
                  varConf = availableVariables(varIdx, :);
                  varName = varConf.('output_name'){1};
                  % TEMPORARY 20241209.
                  if ~strcmp(espEnv.modisData.versionOf.spiresdailytifsinu, 'v2025.nrt')
                    if isempty(who(fileObj, varName))
                        warning('Skip absent variable %s in %s.\n', varName, ...
                          matFilePath);
                        continue;
                    end
                  end
                  % Dirty tweak for v2025.nrt 20241209.
                  if ismember(espEnv.modisData.versionOf.spiresdailytifsinu, {'v2025.nrt'})
                      inputDataLabel = 'spiresdailytifsinu';
                      complementaryLabel = '';
                      data = struct();
                      data.(varName) = espEnv.getDataForDateAndVarName(objectName, ...
                          inputDataLabel, thisDate, varName, complementaryLabel);
                      divisor = 1;
                  else
                      data = load(matFilePath, varConf.('output_name'){1}, ...
                          [varConf.('output_name'){1} '_divisor']);
                      divisor = data.([varConf.('output_name'){1} '_divisor']);
                  end
                  
                  % Handle divisor that is not trivial (and adjust type)
                  % This is special case for v2022.0 albedo variable
                  if divisor ~= 1 && strcmp(writeNetCDFField, 'v2022_0')
                      data.(varConf.('output_name'){1}) = ...
                          cast(...
                          data.(varConf.('output_name'){1}) / double(divisor), ...
                          ESPNetCDF.matClass(varConf.('netCDF_type'){1}));
                  end

                  % Attributes for this variable and the values.
                  attribute = struct(...
                      snowtoday_id = varConf.('id')(1), ...
                      snowtoday_name = varConf.('output_name'){1}, ...
                      long_name = varConf.('netCDF_long_name'){1}, ...
                      units = replace(varConf.('netCDF_units'){1}, '"', ''), ...
                      FillValue = ...
                          cast(varConf.('nodata_value'), ...
                          ESPNetCDF.matClass(varConf.('netCDF_type'){1})), ...
                      valid_range = ...
                          cast([varConf.('min') varConf.('max')], ...
                          ESPNetCDF.matClass(varConf.('netCDF_type'){1})), ...
                      comment = varConf.('netCDF_description'){1}, ...
                      grid_mapping = 'crs'); %'sinusoidal'); % this grid_mapping references the
                          % general grid_mapping and wasn't present in the first versions
                          % of this script (before 2023-08-31).
                      % Before 20241126: description = varConf.('netCDF_description'){1}, ...
                      % Change asked by Kara.
                      
                      % scale_factor = varConf.('netCDF_scale_factor')(1), ...
                  if ~strcmp(varConf.('netCDF_standard_name'){1}, 'none')
                      attribute.standard_name = varConf.('netCDF_standard_name'){1};
                  end
                  if strcmp(varConf.('output_name'){1}, ...
                      'viewable_snow_fraction_status')
                      attribute.flag_values = cast( ...
                          cell2mat(struct2cell(Variables.dataStatus))', ...
                          ESPNetCDF.matClass(varConf.('netCDF_type'){1}));
                      attribute.flag_meanings = strjoin(fieldnames( ...
                          Variables.dataStatus ));
                  end

                  thisNetCDF = thisNetCDF.setVariable( ...
                      data.(varConf.('output_name'){1}), ...
                      varConf.('netCDF_varName'){1}, varConf.('netCDF_type'){1}, ...
                      attribute);
              end % for varIdx.

              % 3. Add a few more global attributes from the .mat file
              % that we want to carry along into the .nc file.
              attribute = struct();
              % Dates and duration in ISO8601. We arbitrarily set the start time to
              % UTC (Z) midnight although it's not, and duration to 1 day.
              attribute.time_coverage_start = string( ...
                  datetime(year(thisDate), month(thisDate), day(thisDate), ...
                  0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ');
              attribute.time_coverage_end = string( ...
                  datetime(year(thisDate), month(thisDate), day(thisDate) + 1, ...
                  0, 0, 0, 0, 'TimeZone', 'Z'), 'yyyy-MM-dd''T''HH:mm:ss.SSSZ');
              attribute.time_coverage_duration = 'P0Y0M1DT0H0M0S';
              
              if ismember(region.espEnv.modisData.versionOf.VariablesNetCDF, ...
                {'v2022.0', 'v2023.0', 'v2023.1', 'v2023.0a', 'v2023.0d'})
                attribute.versionOf_SCAGDRFSSTC = ...
                    region.espEnv.modisData.versionOf.SCAGDRFSSTC;
                attribute.versionOf_VariablesMatlab = ...
                    region.espEnv.modisData.versionOf.VariablesMatlab;
                attribute.versionOf_VariablesNetCDF = ...
                    region.espEnv.modisData.versionOf.VariablesNetCDF;
                    
                 if ismember(attribute.versionOf_VariablesNetCDF, ...
                  {'v2022.0', 'v2023.1', 'v2023.0'})
                  matWantedAttributeNames = {'files', 'stcStruct'};
                    % I didn't put 'mindays', 'zthresh' wich are already in stcStruct.
                end
                % NB: Dirty, to avoid to include this for spires v2024.0. To improve
                %                                                                  @todo

                % NB: it's probably required to have clearer names for metadata    @todo
                versionNetCDFString = replace( ...
                    attribute.versionOf_VariablesNetCDF, '.', '_');
              end
              if ~strcmp(espEnv.modisData.versionOf.spiresdailytifsinu, 'v2025.nrt') % TEMPORARY dirty 20241209.
                  fieldNamesInMat = fieldnames(matfile(matFilePath));
                  matWantedAttributeNames = {};
                 
                  for matWantedAttributeNameIdx = 1:length(matWantedAttributeNames)
                      matWantedAttributeName = ...
                          matWantedAttributeNames{matWantedAttributeNameIdx};
                      % We load the metadata only if there's no default value.
                      if ismember(versionNetCDFString, ...
                          fieldnames(thisNetCDF.defaultAttributeValues)) & ...
                          ismember(matWantedAttributeName, ...
                          fieldnames(thisNetCDF.defaultAttributeValues. ...
                              (versionNetCDFString)))
                          data = thisNetCDF.defaultAttributeValues. ...
                              (versionNetCDFString).(matWantedAttributeName);
                      else
                          data = load(matFilePath, ...
                              matWantedAttributeName).(matWantedAttributeName);
                      end
                      switch matWantedAttributeName
                          case 'files'
                              [~, stcFileName, stcFileExt] = fileparts(data{1,2});
                              attribute.STC_file = sprintf('%s%s', stcFileName, stcFileExt);
      %{
                          case {'zthresh', 'mindays'}
                              attribute.(['STC_', matWantedAttributeName])  = strjoin( ...
                                  string(data{1}));
      %}
                          case 'stcStruct'
                              theseFieldNames = fieldnames(data);
                              for fieldIdx = 1:length(theseFieldNames)
                                  if 1 == numel(data.(theseFieldNames{fieldIdx}))
                                      attribute.(['STC_', theseFieldNames{fieldIdx}]) = ...
                                          string(data.(theseFieldNames{fieldIdx}));
                                  else
                                      attribute.(['STC_', theseFieldNames{fieldIdx}]) = ...
                                          strjoin( ...
                                              string(data.(theseFieldNames{fieldIdx})), ...
                                              ', ');
                                  end
                              end
                      end
                  end
              end
              thisNetCDF.addGlobalAttributes(attribute);

              % 5. Write it out.
              thisNetCDF.closeFile();
%}             
        logger.printDurationAndMemoryUse(dbstack);
        fprintf('%s: Done generating .nc %s from %s.\n', mfilename(), ...
            netCDFFilePath, matFilePath);
      end

	% TBD: we need a function that will make an .nc file from
	% input data instead of from one of the legacy .mat files
    end
end
